/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_gpio.h"

static const char* CMockString_GPIOADCTriggerDisable = "GPIOADCTriggerDisable";
static const char* CMockString_GPIOADCTriggerEnable = "GPIOADCTriggerEnable";
static const char* CMockString_GPIODMATriggerDisable = "GPIODMATriggerDisable";
static const char* CMockString_GPIODMATriggerEnable = "GPIODMATriggerEnable";
static const char* CMockString_GPIODirModeGet = "GPIODirModeGet";
static const char* CMockString_GPIODirModeSet = "GPIODirModeSet";
static const char* CMockString_GPIOIntClear = "GPIOIntClear";
static const char* CMockString_GPIOIntDisable = "GPIOIntDisable";
static const char* CMockString_GPIOIntEnable = "GPIOIntEnable";
static const char* CMockString_GPIOIntRegister = "GPIOIntRegister";
static const char* CMockString_GPIOIntRegisterPin = "GPIOIntRegisterPin";
static const char* CMockString_GPIOIntStatus = "GPIOIntStatus";
static const char* CMockString_GPIOIntTypeGet = "GPIOIntTypeGet";
static const char* CMockString_GPIOIntTypeSet = "GPIOIntTypeSet";
static const char* CMockString_GPIOIntUnregister = "GPIOIntUnregister";
static const char* CMockString_GPIOIntUnregisterPin = "GPIOIntUnregisterPin";
static const char* CMockString_GPIOPadConfigGet = "GPIOPadConfigGet";
static const char* CMockString_GPIOPadConfigSet = "GPIOPadConfigSet";
static const char* CMockString_GPIOPinConfigure = "GPIOPinConfigure";
static const char* CMockString_GPIOPinRead = "GPIOPinRead";
static const char* CMockString_GPIOPinTypeADC = "GPIOPinTypeADC";
static const char* CMockString_GPIOPinTypeCAN = "GPIOPinTypeCAN";
static const char* CMockString_GPIOPinTypeComparator = "GPIOPinTypeComparator";
static const char* CMockString_GPIOPinTypeComparatorOutput = "GPIOPinTypeComparatorOutput";
static const char* CMockString_GPIOPinTypeDIVSCLK = "GPIOPinTypeDIVSCLK";
static const char* CMockString_GPIOPinTypeEPI = "GPIOPinTypeEPI";
static const char* CMockString_GPIOPinTypeEthernetLED = "GPIOPinTypeEthernetLED";
static const char* CMockString_GPIOPinTypeEthernetMII = "GPIOPinTypeEthernetMII";
static const char* CMockString_GPIOPinTypeGPIOInput = "GPIOPinTypeGPIOInput";
static const char* CMockString_GPIOPinTypeGPIOOutput = "GPIOPinTypeGPIOOutput";
static const char* CMockString_GPIOPinTypeGPIOOutputOD = "GPIOPinTypeGPIOOutputOD";
static const char* CMockString_GPIOPinTypeHibernateRTCCLK = "GPIOPinTypeHibernateRTCCLK";
static const char* CMockString_GPIOPinTypeI2C = "GPIOPinTypeI2C";
static const char* CMockString_GPIOPinTypeI2CSCL = "GPIOPinTypeI2CSCL";
static const char* CMockString_GPIOPinTypeLCD = "GPIOPinTypeLCD";
static const char* CMockString_GPIOPinTypeOneWire = "GPIOPinTypeOneWire";
static const char* CMockString_GPIOPinTypePWM = "GPIOPinTypePWM";
static const char* CMockString_GPIOPinTypeQEI = "GPIOPinTypeQEI";
static const char* CMockString_GPIOPinTypeSSI = "GPIOPinTypeSSI";
static const char* CMockString_GPIOPinTypeTimer = "GPIOPinTypeTimer";
static const char* CMockString_GPIOPinTypeTrace = "GPIOPinTypeTrace";
static const char* CMockString_GPIOPinTypeUART = "GPIOPinTypeUART";
static const char* CMockString_GPIOPinTypeUSBAnalog = "GPIOPinTypeUSBAnalog";
static const char* CMockString_GPIOPinTypeUSBDigital = "GPIOPinTypeUSBDigital";
static const char* CMockString_GPIOPinTypeWakeHigh = "GPIOPinTypeWakeHigh";
static const char* CMockString_GPIOPinTypeWakeLow = "GPIOPinTypeWakeLow";
static const char* CMockString_GPIOPinWakeStatus = "GPIOPinWakeStatus";
static const char* CMockString_GPIOPinWrite = "GPIOPinWrite";
static const char* CMockString_bMasked = "bMasked";
static const char* CMockString_pfnIntHandler = "pfnIntHandler";
static const char* CMockString_pui32PadType = "pui32PadType";
static const char* CMockString_pui32Strength = "pui32Strength";
static const char* CMockString_ui32IntFlags = "ui32IntFlags";
static const char* CMockString_ui32IntType = "ui32IntType";
static const char* CMockString_ui32PadType = "ui32PadType";
static const char* CMockString_ui32Pin = "ui32Pin";
static const char* CMockString_ui32PinConfig = "ui32PinConfig";
static const char* CMockString_ui32PinIO = "ui32PinIO";
static const char* CMockString_ui32Port = "ui32Port";
static const char* CMockString_ui32Strength = "ui32Strength";
static const char* CMockString_ui8Pin = "ui8Pin";
static const char* CMockString_ui8Pins = "ui8Pins";
static const char* CMockString_ui8Val = "ui8Val";

typedef struct _CMOCK_GPIODirModeSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;
  uint32_t Expected_ui32PinIO;

} CMOCK_GPIODirModeSet_CALL_INSTANCE;

typedef struct _CMOCK_GPIODirModeGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pin;

} CMOCK_GPIODirModeGet_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntTypeSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;
  uint32_t Expected_ui32IntType;

} CMOCK_GPIOIntTypeSet_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntTypeGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pin;

} CMOCK_GPIOIntTypeGet_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPadConfigSet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;
  uint32_t Expected_ui32Strength;
  uint32_t Expected_ui32PadType;

} CMOCK_GPIOPadConfigSet_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPadConfigGet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pin;
  uint32_t* Expected_pui32Strength;
  uint32_t* Expected_pui32PadType;

} CMOCK_GPIOPadConfigGet_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntEnable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint32_t Expected_ui32IntFlags;

} CMOCK_GPIOIntEnable_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntDisable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint32_t Expected_ui32IntFlags;

} CMOCK_GPIOIntDisable_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntStatus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_ui32Port;
  bool Expected_bMasked;

} CMOCK_GPIOIntStatus_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntClear_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint32_t Expected_ui32IntFlags;

} CMOCK_GPIOIntClear_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntRegister_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  cmock_gpio_func_ptr1 Expected_pfnIntHandler;

} CMOCK_GPIOIntRegister_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntUnregister_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;

} CMOCK_GPIOIntUnregister_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntRegisterPin_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint32_t Expected_ui32Pin;
  cmock_gpio_func_ptr2 Expected_pfnIntHandler;

} CMOCK_GPIOIntRegisterPin_CALL_INSTANCE;

typedef struct _CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint32_t Expected_ui32Pin;

} CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinRead_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinRead_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinWrite_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;
  uint8_t Expected_ui8Val;

} CMOCK_GPIOPinWrite_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinConfigure_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32PinConfig;

} CMOCK_GPIOPinConfigure_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeADC_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeADC_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeCAN_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeCAN_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeComparator_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeComparator_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeEPI_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeEPI_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeI2C_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeI2C_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeLCD_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeLCD_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypePWM_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypePWM_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeQEI_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeQEI_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeSSI_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeSSI_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeTimer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeTimer_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeTrace_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeTrace_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeUART_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeUART_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE;

typedef struct _CMOCK_GPIOPinWakeStatus_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  int CallOrder;
  uint32_t Expected_ui32Port;

} CMOCK_GPIOPinWakeStatus_CALL_INSTANCE;

typedef struct _CMOCK_GPIODMATriggerEnable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIODMATriggerEnable_CALL_INSTANCE;

typedef struct _CMOCK_GPIODMATriggerDisable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIODMATriggerDisable_CALL_INSTANCE;

typedef struct _CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE;

typedef struct _CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_ui32Port;
  uint8_t Expected_ui8Pins;

} CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE;

static struct mock_gpioInstance
{
  char GPIODirModeSet_IgnoreBool;
  char GPIODirModeSet_CallbackBool;
  CMOCK_GPIODirModeSet_CALLBACK GPIODirModeSet_CallbackFunctionPointer;
  int GPIODirModeSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIODirModeSet_CallInstance;
  char GPIODirModeGet_IgnoreBool;
  uint32_t GPIODirModeGet_FinalReturn;
  char GPIODirModeGet_CallbackBool;
  CMOCK_GPIODirModeGet_CALLBACK GPIODirModeGet_CallbackFunctionPointer;
  int GPIODirModeGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIODirModeGet_CallInstance;
  char GPIOIntTypeSet_IgnoreBool;
  char GPIOIntTypeSet_CallbackBool;
  CMOCK_GPIOIntTypeSet_CALLBACK GPIOIntTypeSet_CallbackFunctionPointer;
  int GPIOIntTypeSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntTypeSet_CallInstance;
  char GPIOIntTypeGet_IgnoreBool;
  uint32_t GPIOIntTypeGet_FinalReturn;
  char GPIOIntTypeGet_CallbackBool;
  CMOCK_GPIOIntTypeGet_CALLBACK GPIOIntTypeGet_CallbackFunctionPointer;
  int GPIOIntTypeGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntTypeGet_CallInstance;
  char GPIOPadConfigSet_IgnoreBool;
  char GPIOPadConfigSet_CallbackBool;
  CMOCK_GPIOPadConfigSet_CALLBACK GPIOPadConfigSet_CallbackFunctionPointer;
  int GPIOPadConfigSet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPadConfigSet_CallInstance;
  char GPIOPadConfigGet_IgnoreBool;
  char GPIOPadConfigGet_CallbackBool;
  CMOCK_GPIOPadConfigGet_CALLBACK GPIOPadConfigGet_CallbackFunctionPointer;
  int GPIOPadConfigGet_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPadConfigGet_CallInstance;
  char GPIOIntEnable_IgnoreBool;
  char GPIOIntEnable_CallbackBool;
  CMOCK_GPIOIntEnable_CALLBACK GPIOIntEnable_CallbackFunctionPointer;
  int GPIOIntEnable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntEnable_CallInstance;
  char GPIOIntDisable_IgnoreBool;
  char GPIOIntDisable_CallbackBool;
  CMOCK_GPIOIntDisable_CALLBACK GPIOIntDisable_CallbackFunctionPointer;
  int GPIOIntDisable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntDisable_CallInstance;
  char GPIOIntStatus_IgnoreBool;
  uint32_t GPIOIntStatus_FinalReturn;
  char GPIOIntStatus_CallbackBool;
  CMOCK_GPIOIntStatus_CALLBACK GPIOIntStatus_CallbackFunctionPointer;
  int GPIOIntStatus_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntStatus_CallInstance;
  char GPIOIntClear_IgnoreBool;
  char GPIOIntClear_CallbackBool;
  CMOCK_GPIOIntClear_CALLBACK GPIOIntClear_CallbackFunctionPointer;
  int GPIOIntClear_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntClear_CallInstance;
  char GPIOIntRegister_IgnoreBool;
  char GPIOIntRegister_CallbackBool;
  CMOCK_GPIOIntRegister_CALLBACK GPIOIntRegister_CallbackFunctionPointer;
  int GPIOIntRegister_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntRegister_CallInstance;
  char GPIOIntUnregister_IgnoreBool;
  char GPIOIntUnregister_CallbackBool;
  CMOCK_GPIOIntUnregister_CALLBACK GPIOIntUnregister_CallbackFunctionPointer;
  int GPIOIntUnregister_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntUnregister_CallInstance;
  char GPIOIntRegisterPin_IgnoreBool;
  char GPIOIntRegisterPin_CallbackBool;
  CMOCK_GPIOIntRegisterPin_CALLBACK GPIOIntRegisterPin_CallbackFunctionPointer;
  int GPIOIntRegisterPin_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntRegisterPin_CallInstance;
  char GPIOIntUnregisterPin_IgnoreBool;
  char GPIOIntUnregisterPin_CallbackBool;
  CMOCK_GPIOIntUnregisterPin_CALLBACK GPIOIntUnregisterPin_CallbackFunctionPointer;
  int GPIOIntUnregisterPin_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOIntUnregisterPin_CallInstance;
  char GPIOPinRead_IgnoreBool;
  int32_t GPIOPinRead_FinalReturn;
  char GPIOPinRead_CallbackBool;
  CMOCK_GPIOPinRead_CALLBACK GPIOPinRead_CallbackFunctionPointer;
  int GPIOPinRead_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinRead_CallInstance;
  char GPIOPinWrite_IgnoreBool;
  char GPIOPinWrite_CallbackBool;
  CMOCK_GPIOPinWrite_CALLBACK GPIOPinWrite_CallbackFunctionPointer;
  int GPIOPinWrite_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinWrite_CallInstance;
  char GPIOPinConfigure_IgnoreBool;
  char GPIOPinConfigure_CallbackBool;
  CMOCK_GPIOPinConfigure_CALLBACK GPIOPinConfigure_CallbackFunctionPointer;
  int GPIOPinConfigure_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinConfigure_CallInstance;
  char GPIOPinTypeADC_IgnoreBool;
  char GPIOPinTypeADC_CallbackBool;
  CMOCK_GPIOPinTypeADC_CALLBACK GPIOPinTypeADC_CallbackFunctionPointer;
  int GPIOPinTypeADC_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeADC_CallInstance;
  char GPIOPinTypeCAN_IgnoreBool;
  char GPIOPinTypeCAN_CallbackBool;
  CMOCK_GPIOPinTypeCAN_CALLBACK GPIOPinTypeCAN_CallbackFunctionPointer;
  int GPIOPinTypeCAN_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeCAN_CallInstance;
  char GPIOPinTypeComparator_IgnoreBool;
  char GPIOPinTypeComparator_CallbackBool;
  CMOCK_GPIOPinTypeComparator_CALLBACK GPIOPinTypeComparator_CallbackFunctionPointer;
  int GPIOPinTypeComparator_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeComparator_CallInstance;
  char GPIOPinTypeComparatorOutput_IgnoreBool;
  char GPIOPinTypeComparatorOutput_CallbackBool;
  CMOCK_GPIOPinTypeComparatorOutput_CALLBACK GPIOPinTypeComparatorOutput_CallbackFunctionPointer;
  int GPIOPinTypeComparatorOutput_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeComparatorOutput_CallInstance;
  char GPIOPinTypeDIVSCLK_IgnoreBool;
  char GPIOPinTypeDIVSCLK_CallbackBool;
  CMOCK_GPIOPinTypeDIVSCLK_CALLBACK GPIOPinTypeDIVSCLK_CallbackFunctionPointer;
  int GPIOPinTypeDIVSCLK_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeDIVSCLK_CallInstance;
  char GPIOPinTypeEPI_IgnoreBool;
  char GPIOPinTypeEPI_CallbackBool;
  CMOCK_GPIOPinTypeEPI_CALLBACK GPIOPinTypeEPI_CallbackFunctionPointer;
  int GPIOPinTypeEPI_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeEPI_CallInstance;
  char GPIOPinTypeEthernetLED_IgnoreBool;
  char GPIOPinTypeEthernetLED_CallbackBool;
  CMOCK_GPIOPinTypeEthernetLED_CALLBACK GPIOPinTypeEthernetLED_CallbackFunctionPointer;
  int GPIOPinTypeEthernetLED_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeEthernetLED_CallInstance;
  char GPIOPinTypeEthernetMII_IgnoreBool;
  char GPIOPinTypeEthernetMII_CallbackBool;
  CMOCK_GPIOPinTypeEthernetMII_CALLBACK GPIOPinTypeEthernetMII_CallbackFunctionPointer;
  int GPIOPinTypeEthernetMII_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeEthernetMII_CallInstance;
  char GPIOPinTypeGPIOInput_IgnoreBool;
  char GPIOPinTypeGPIOInput_CallbackBool;
  CMOCK_GPIOPinTypeGPIOInput_CALLBACK GPIOPinTypeGPIOInput_CallbackFunctionPointer;
  int GPIOPinTypeGPIOInput_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeGPIOInput_CallInstance;
  char GPIOPinTypeGPIOOutput_IgnoreBool;
  char GPIOPinTypeGPIOOutput_CallbackBool;
  CMOCK_GPIOPinTypeGPIOOutput_CALLBACK GPIOPinTypeGPIOOutput_CallbackFunctionPointer;
  int GPIOPinTypeGPIOOutput_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeGPIOOutput_CallInstance;
  char GPIOPinTypeGPIOOutputOD_IgnoreBool;
  char GPIOPinTypeGPIOOutputOD_CallbackBool;
  CMOCK_GPIOPinTypeGPIOOutputOD_CALLBACK GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer;
  int GPIOPinTypeGPIOOutputOD_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeGPIOOutputOD_CallInstance;
  char GPIOPinTypeHibernateRTCCLK_IgnoreBool;
  char GPIOPinTypeHibernateRTCCLK_CallbackBool;
  CMOCK_GPIOPinTypeHibernateRTCCLK_CALLBACK GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer;
  int GPIOPinTypeHibernateRTCCLK_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeHibernateRTCCLK_CallInstance;
  char GPIOPinTypeI2C_IgnoreBool;
  char GPIOPinTypeI2C_CallbackBool;
  CMOCK_GPIOPinTypeI2C_CALLBACK GPIOPinTypeI2C_CallbackFunctionPointer;
  int GPIOPinTypeI2C_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeI2C_CallInstance;
  char GPIOPinTypeI2CSCL_IgnoreBool;
  char GPIOPinTypeI2CSCL_CallbackBool;
  CMOCK_GPIOPinTypeI2CSCL_CALLBACK GPIOPinTypeI2CSCL_CallbackFunctionPointer;
  int GPIOPinTypeI2CSCL_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeI2CSCL_CallInstance;
  char GPIOPinTypeLCD_IgnoreBool;
  char GPIOPinTypeLCD_CallbackBool;
  CMOCK_GPIOPinTypeLCD_CALLBACK GPIOPinTypeLCD_CallbackFunctionPointer;
  int GPIOPinTypeLCD_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeLCD_CallInstance;
  char GPIOPinTypeOneWire_IgnoreBool;
  char GPIOPinTypeOneWire_CallbackBool;
  CMOCK_GPIOPinTypeOneWire_CALLBACK GPIOPinTypeOneWire_CallbackFunctionPointer;
  int GPIOPinTypeOneWire_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeOneWire_CallInstance;
  char GPIOPinTypePWM_IgnoreBool;
  char GPIOPinTypePWM_CallbackBool;
  CMOCK_GPIOPinTypePWM_CALLBACK GPIOPinTypePWM_CallbackFunctionPointer;
  int GPIOPinTypePWM_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypePWM_CallInstance;
  char GPIOPinTypeQEI_IgnoreBool;
  char GPIOPinTypeQEI_CallbackBool;
  CMOCK_GPIOPinTypeQEI_CALLBACK GPIOPinTypeQEI_CallbackFunctionPointer;
  int GPIOPinTypeQEI_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeQEI_CallInstance;
  char GPIOPinTypeSSI_IgnoreBool;
  char GPIOPinTypeSSI_CallbackBool;
  CMOCK_GPIOPinTypeSSI_CALLBACK GPIOPinTypeSSI_CallbackFunctionPointer;
  int GPIOPinTypeSSI_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeSSI_CallInstance;
  char GPIOPinTypeTimer_IgnoreBool;
  char GPIOPinTypeTimer_CallbackBool;
  CMOCK_GPIOPinTypeTimer_CALLBACK GPIOPinTypeTimer_CallbackFunctionPointer;
  int GPIOPinTypeTimer_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeTimer_CallInstance;
  char GPIOPinTypeTrace_IgnoreBool;
  char GPIOPinTypeTrace_CallbackBool;
  CMOCK_GPIOPinTypeTrace_CALLBACK GPIOPinTypeTrace_CallbackFunctionPointer;
  int GPIOPinTypeTrace_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeTrace_CallInstance;
  char GPIOPinTypeUART_IgnoreBool;
  char GPIOPinTypeUART_CallbackBool;
  CMOCK_GPIOPinTypeUART_CALLBACK GPIOPinTypeUART_CallbackFunctionPointer;
  int GPIOPinTypeUART_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeUART_CallInstance;
  char GPIOPinTypeUSBAnalog_IgnoreBool;
  char GPIOPinTypeUSBAnalog_CallbackBool;
  CMOCK_GPIOPinTypeUSBAnalog_CALLBACK GPIOPinTypeUSBAnalog_CallbackFunctionPointer;
  int GPIOPinTypeUSBAnalog_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeUSBAnalog_CallInstance;
  char GPIOPinTypeUSBDigital_IgnoreBool;
  char GPIOPinTypeUSBDigital_CallbackBool;
  CMOCK_GPIOPinTypeUSBDigital_CALLBACK GPIOPinTypeUSBDigital_CallbackFunctionPointer;
  int GPIOPinTypeUSBDigital_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeUSBDigital_CallInstance;
  char GPIOPinTypeWakeHigh_IgnoreBool;
  char GPIOPinTypeWakeHigh_CallbackBool;
  CMOCK_GPIOPinTypeWakeHigh_CALLBACK GPIOPinTypeWakeHigh_CallbackFunctionPointer;
  int GPIOPinTypeWakeHigh_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeWakeHigh_CallInstance;
  char GPIOPinTypeWakeLow_IgnoreBool;
  char GPIOPinTypeWakeLow_CallbackBool;
  CMOCK_GPIOPinTypeWakeLow_CALLBACK GPIOPinTypeWakeLow_CallbackFunctionPointer;
  int GPIOPinTypeWakeLow_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinTypeWakeLow_CallInstance;
  char GPIOPinWakeStatus_IgnoreBool;
  uint32_t GPIOPinWakeStatus_FinalReturn;
  char GPIOPinWakeStatus_CallbackBool;
  CMOCK_GPIOPinWakeStatus_CALLBACK GPIOPinWakeStatus_CallbackFunctionPointer;
  int GPIOPinWakeStatus_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOPinWakeStatus_CallInstance;
  char GPIODMATriggerEnable_IgnoreBool;
  char GPIODMATriggerEnable_CallbackBool;
  CMOCK_GPIODMATriggerEnable_CALLBACK GPIODMATriggerEnable_CallbackFunctionPointer;
  int GPIODMATriggerEnable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIODMATriggerEnable_CallInstance;
  char GPIODMATriggerDisable_IgnoreBool;
  char GPIODMATriggerDisable_CallbackBool;
  CMOCK_GPIODMATriggerDisable_CALLBACK GPIODMATriggerDisable_CallbackFunctionPointer;
  int GPIODMATriggerDisable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIODMATriggerDisable_CallInstance;
  char GPIOADCTriggerEnable_IgnoreBool;
  char GPIOADCTriggerEnable_CallbackBool;
  CMOCK_GPIOADCTriggerEnable_CALLBACK GPIOADCTriggerEnable_CallbackFunctionPointer;
  int GPIOADCTriggerEnable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOADCTriggerEnable_CallInstance;
  char GPIOADCTriggerDisable_IgnoreBool;
  char GPIOADCTriggerDisable_CallbackBool;
  CMOCK_GPIOADCTriggerDisable_CALLBACK GPIOADCTriggerDisable_CallbackFunctionPointer;
  int GPIOADCTriggerDisable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE GPIOADCTriggerDisable_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_gpio_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.GPIODirModeSet_CallInstance;
  if (Mock.GPIODirModeSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIODirModeSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIODirModeSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIODirModeGet_CallInstance;
  if (Mock.GPIODirModeGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIODirModeGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIODirModeGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntTypeSet_CallInstance;
  if (Mock.GPIOIntTypeSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntTypeSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntTypeSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntTypeGet_CallInstance;
  if (Mock.GPIOIntTypeGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntTypeGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntTypeGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPadConfigSet_CallInstance;
  if (Mock.GPIOPadConfigSet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPadConfigSet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPadConfigSet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPadConfigGet_CallInstance;
  if (Mock.GPIOPadConfigGet_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPadConfigGet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPadConfigGet_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntEnable_CallInstance;
  if (Mock.GPIOIntEnable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntEnable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntEnable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntDisable_CallInstance;
  if (Mock.GPIOIntDisable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntDisable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntDisable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntStatus_CallInstance;
  if (Mock.GPIOIntStatus_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntStatus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntStatus_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntClear_CallInstance;
  if (Mock.GPIOIntClear_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntClear);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntClear_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntRegister_CallInstance;
  if (Mock.GPIOIntRegister_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntRegister);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntRegister_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntUnregister_CallInstance;
  if (Mock.GPIOIntUnregister_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntUnregister);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntUnregister_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntRegisterPin_CallInstance;
  if (Mock.GPIOIntRegisterPin_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntRegisterPin);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntRegisterPin_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOIntUnregisterPin_CallInstance;
  if (Mock.GPIOIntUnregisterPin_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOIntUnregisterPin);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOIntUnregisterPin_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinRead_CallInstance;
  if (Mock.GPIOPinRead_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinRead);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinRead_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinWrite_CallInstance;
  if (Mock.GPIOPinWrite_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinWrite);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinWrite_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinConfigure_CallInstance;
  if (Mock.GPIOPinConfigure_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinConfigure);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinConfigure_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeADC_CallInstance;
  if (Mock.GPIOPinTypeADC_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeADC);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeADC_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeCAN_CallInstance;
  if (Mock.GPIOPinTypeCAN_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeCAN);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeCAN_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeComparator_CallInstance;
  if (Mock.GPIOPinTypeComparator_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeComparator);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeComparator_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeComparatorOutput_CallInstance;
  if (Mock.GPIOPinTypeComparatorOutput_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeComparatorOutput);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeComparatorOutput_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeDIVSCLK_CallInstance;
  if (Mock.GPIOPinTypeDIVSCLK_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeDIVSCLK);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeDIVSCLK_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeEPI_CallInstance;
  if (Mock.GPIOPinTypeEPI_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeEPI);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeEPI_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeEthernetLED_CallInstance;
  if (Mock.GPIOPinTypeEthernetLED_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeEthernetLED);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeEthernetLED_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeEthernetMII_CallInstance;
  if (Mock.GPIOPinTypeEthernetMII_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeEthernetMII);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeEthernetMII_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeGPIOInput_CallInstance;
  if (Mock.GPIOPinTypeGPIOInput_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeGPIOInput);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeGPIOInput_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeGPIOOutput_CallInstance;
  if (Mock.GPIOPinTypeGPIOOutput_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeGPIOOutput);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeGPIOOutput_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeGPIOOutputOD_CallInstance;
  if (Mock.GPIOPinTypeGPIOOutputOD_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeGPIOOutputOD);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeHibernateRTCCLK_CallInstance;
  if (Mock.GPIOPinTypeHibernateRTCCLK_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeHibernateRTCCLK);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeI2C_CallInstance;
  if (Mock.GPIOPinTypeI2C_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeI2C);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeI2C_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeI2CSCL_CallInstance;
  if (Mock.GPIOPinTypeI2CSCL_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeI2CSCL);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeI2CSCL_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeLCD_CallInstance;
  if (Mock.GPIOPinTypeLCD_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeLCD);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeLCD_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeOneWire_CallInstance;
  if (Mock.GPIOPinTypeOneWire_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeOneWire);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeOneWire_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypePWM_CallInstance;
  if (Mock.GPIOPinTypePWM_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypePWM);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypePWM_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeQEI_CallInstance;
  if (Mock.GPIOPinTypeQEI_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeQEI);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeQEI_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeSSI_CallInstance;
  if (Mock.GPIOPinTypeSSI_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeSSI);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeSSI_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeTimer_CallInstance;
  if (Mock.GPIOPinTypeTimer_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeTimer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeTimer_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeTrace_CallInstance;
  if (Mock.GPIOPinTypeTrace_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeTrace);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeTrace_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeUART_CallInstance;
  if (Mock.GPIOPinTypeUART_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeUART);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeUART_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeUSBAnalog_CallInstance;
  if (Mock.GPIOPinTypeUSBAnalog_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeUSBAnalog);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeUSBAnalog_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeUSBDigital_CallInstance;
  if (Mock.GPIOPinTypeUSBDigital_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeUSBDigital);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeUSBDigital_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeWakeHigh_CallInstance;
  if (Mock.GPIOPinTypeWakeHigh_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeWakeHigh);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeWakeHigh_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinTypeWakeLow_CallInstance;
  if (Mock.GPIOPinTypeWakeLow_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinTypeWakeLow);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinTypeWakeLow_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOPinWakeStatus_CallInstance;
  if (Mock.GPIOPinWakeStatus_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOPinWakeStatus);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOPinWakeStatus_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIODMATriggerEnable_CallInstance;
  if (Mock.GPIODMATriggerEnable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIODMATriggerEnable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIODMATriggerEnable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIODMATriggerDisable_CallInstance;
  if (Mock.GPIODMATriggerDisable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIODMATriggerDisable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIODMATriggerDisable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOADCTriggerEnable_CallInstance;
  if (Mock.GPIOADCTriggerEnable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOADCTriggerEnable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOADCTriggerEnable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.GPIOADCTriggerDisable_CallInstance;
  if (Mock.GPIOADCTriggerDisable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_GPIOADCTriggerDisable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.GPIOADCTriggerDisable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_gpio_Init(void)
{
  mock_gpio_Destroy();
}

void mock_gpio_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

void GPIODirModeSet(uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32PinIO)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIODirModeSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIODirModeSet);
  cmock_call_instance = (CMOCK_GPIODirModeSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIODirModeSet_CallInstance);
  Mock.GPIODirModeSet_CallInstance = CMock_Guts_MemNext(Mock.GPIODirModeSet_CallInstance);
  if (Mock.GPIODirModeSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIODirModeSet_CallbackBool &&
      Mock.GPIODirModeSet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIODirModeSet_CallbackFunctionPointer(ui32Port, ui8Pins, ui32PinIO, Mock.GPIODirModeSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIODirModeSet,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIODirModeSet,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIODirModeSet,CMockString_ui32PinIO);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32PinIO, ui32PinIO, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIODirModeSet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIODirModeSet_CallbackFunctionPointer(ui32Port, ui8Pins, ui32PinIO, Mock.GPIODirModeSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIODirModeSet(CMOCK_GPIODirModeSet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32PinIO);
void CMockExpectParameters_GPIODirModeSet(CMOCK_GPIODirModeSet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32PinIO)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
  cmock_call_instance->Expected_ui32PinIO = ui32PinIO;
}

void GPIODirModeSet_CMockIgnore(void)
{
  Mock.GPIODirModeSet_IgnoreBool = (char)1;
}

void GPIODirModeSet_CMockStopIgnore(void)
{
  Mock.GPIODirModeSet_IgnoreBool = (char)0;
}

void GPIODirModeSet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32PinIO)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIODirModeSet_CALL_INSTANCE));
  CMOCK_GPIODirModeSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIODirModeSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIODirModeSet_CallInstance = CMock_Guts_MemChain(Mock.GPIODirModeSet_CallInstance, cmock_guts_index);
  Mock.GPIODirModeSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIODirModeSet(cmock_call_instance, ui32Port, ui8Pins, ui32PinIO);
}

void GPIODirModeSet_AddCallback(CMOCK_GPIODirModeSet_CALLBACK Callback)
{
  Mock.GPIODirModeSet_IgnoreBool = (char)0;
  Mock.GPIODirModeSet_CallbackBool = (char)1;
  Mock.GPIODirModeSet_CallbackFunctionPointer = Callback;
}

void GPIODirModeSet_Stub(CMOCK_GPIODirModeSet_CALLBACK Callback)
{
  Mock.GPIODirModeSet_IgnoreBool = (char)0;
  Mock.GPIODirModeSet_CallbackBool = (char)0;
  Mock.GPIODirModeSet_CallbackFunctionPointer = Callback;
}

uint32_t GPIODirModeGet(uint32_t ui32Port, uint8_t ui8Pin)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIODirModeGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIODirModeGet);
  cmock_call_instance = (CMOCK_GPIODirModeGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIODirModeGet_CallInstance);
  Mock.GPIODirModeGet_CallInstance = CMock_Guts_MemNext(Mock.GPIODirModeGet_CallInstance);
  if (Mock.GPIODirModeGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.GPIODirModeGet_FinalReturn;
    Mock.GPIODirModeGet_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.GPIODirModeGet_CallbackBool &&
      Mock.GPIODirModeGet_CallbackFunctionPointer != NULL)
  {
    uint32_t cmock_cb_ret = Mock.GPIODirModeGet_CallbackFunctionPointer(ui32Port, ui8Pin, Mock.GPIODirModeGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIODirModeGet,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIODirModeGet,CMockString_ui8Pin);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pin, ui8Pin, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIODirModeGet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.GPIODirModeGet_CallbackFunctionPointer(ui32Port, ui8Pin, Mock.GPIODirModeGet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GPIODirModeGet(CMOCK_GPIODirModeGet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pin);
void CMockExpectParameters_GPIODirModeGet(CMOCK_GPIODirModeGet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pin)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pin = ui8Pin;
}

void GPIODirModeGet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIODirModeGet_CALL_INSTANCE));
  CMOCK_GPIODirModeGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIODirModeGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIODirModeGet_CallInstance = CMock_Guts_MemChain(Mock.GPIODirModeGet_CallInstance, cmock_guts_index);
  Mock.GPIODirModeGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.GPIODirModeGet_IgnoreBool = (char)1;
}

void GPIODirModeGet_CMockStopIgnore(void)
{
  if(Mock.GPIODirModeGet_IgnoreBool)
    Mock.GPIODirModeGet_CallInstance = CMock_Guts_MemNext(Mock.GPIODirModeGet_CallInstance);
  Mock.GPIODirModeGet_IgnoreBool = (char)0;
}

void GPIODirModeGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pin, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIODirModeGet_CALL_INSTANCE));
  CMOCK_GPIODirModeGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIODirModeGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIODirModeGet_CallInstance = CMock_Guts_MemChain(Mock.GPIODirModeGet_CallInstance, cmock_guts_index);
  Mock.GPIODirModeGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIODirModeGet(cmock_call_instance, ui32Port, ui8Pin);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void GPIODirModeGet_AddCallback(CMOCK_GPIODirModeGet_CALLBACK Callback)
{
  Mock.GPIODirModeGet_IgnoreBool = (char)0;
  Mock.GPIODirModeGet_CallbackBool = (char)1;
  Mock.GPIODirModeGet_CallbackFunctionPointer = Callback;
}

void GPIODirModeGet_Stub(CMOCK_GPIODirModeGet_CALLBACK Callback)
{
  Mock.GPIODirModeGet_IgnoreBool = (char)0;
  Mock.GPIODirModeGet_CallbackBool = (char)0;
  Mock.GPIODirModeGet_CallbackFunctionPointer = Callback;
}

void GPIOIntTypeSet(uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32IntType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntTypeSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntTypeSet);
  cmock_call_instance = (CMOCK_GPIOIntTypeSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntTypeSet_CallInstance);
  Mock.GPIOIntTypeSet_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntTypeSet_CallInstance);
  if (Mock.GPIOIntTypeSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntTypeSet_CallbackBool &&
      Mock.GPIOIntTypeSet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntTypeSet_CallbackFunctionPointer(ui32Port, ui8Pins, ui32IntType, Mock.GPIOIntTypeSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntTypeSet,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntTypeSet,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntTypeSet,CMockString_ui32IntType);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32IntType, ui32IntType, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntTypeSet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntTypeSet_CallbackFunctionPointer(ui32Port, ui8Pins, ui32IntType, Mock.GPIOIntTypeSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntTypeSet(CMOCK_GPIOIntTypeSet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32IntType);
void CMockExpectParameters_GPIOIntTypeSet(CMOCK_GPIOIntTypeSet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32IntType)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
  cmock_call_instance->Expected_ui32IntType = ui32IntType;
}

void GPIOIntTypeSet_CMockIgnore(void)
{
  Mock.GPIOIntTypeSet_IgnoreBool = (char)1;
}

void GPIOIntTypeSet_CMockStopIgnore(void)
{
  Mock.GPIOIntTypeSet_IgnoreBool = (char)0;
}

void GPIOIntTypeSet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32IntType)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntTypeSet_CALL_INSTANCE));
  CMOCK_GPIOIntTypeSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntTypeSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntTypeSet_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntTypeSet_CallInstance, cmock_guts_index);
  Mock.GPIOIntTypeSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntTypeSet(cmock_call_instance, ui32Port, ui8Pins, ui32IntType);
}

void GPIOIntTypeSet_AddCallback(CMOCK_GPIOIntTypeSet_CALLBACK Callback)
{
  Mock.GPIOIntTypeSet_IgnoreBool = (char)0;
  Mock.GPIOIntTypeSet_CallbackBool = (char)1;
  Mock.GPIOIntTypeSet_CallbackFunctionPointer = Callback;
}

void GPIOIntTypeSet_Stub(CMOCK_GPIOIntTypeSet_CALLBACK Callback)
{
  Mock.GPIOIntTypeSet_IgnoreBool = (char)0;
  Mock.GPIOIntTypeSet_CallbackBool = (char)0;
  Mock.GPIOIntTypeSet_CallbackFunctionPointer = Callback;
}

uint32_t GPIOIntTypeGet(uint32_t ui32Port, uint8_t ui8Pin)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntTypeGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntTypeGet);
  cmock_call_instance = (CMOCK_GPIOIntTypeGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntTypeGet_CallInstance);
  Mock.GPIOIntTypeGet_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntTypeGet_CallInstance);
  if (Mock.GPIOIntTypeGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.GPIOIntTypeGet_FinalReturn;
    Mock.GPIOIntTypeGet_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.GPIOIntTypeGet_CallbackBool &&
      Mock.GPIOIntTypeGet_CallbackFunctionPointer != NULL)
  {
    uint32_t cmock_cb_ret = Mock.GPIOIntTypeGet_CallbackFunctionPointer(ui32Port, ui8Pin, Mock.GPIOIntTypeGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntTypeGet,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntTypeGet,CMockString_ui8Pin);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pin, ui8Pin, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntTypeGet_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.GPIOIntTypeGet_CallbackFunctionPointer(ui32Port, ui8Pin, Mock.GPIOIntTypeGet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GPIOIntTypeGet(CMOCK_GPIOIntTypeGet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pin);
void CMockExpectParameters_GPIOIntTypeGet(CMOCK_GPIOIntTypeGet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pin)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pin = ui8Pin;
}

void GPIOIntTypeGet_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntTypeGet_CALL_INSTANCE));
  CMOCK_GPIOIntTypeGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntTypeGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntTypeGet_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntTypeGet_CallInstance, cmock_guts_index);
  Mock.GPIOIntTypeGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.GPIOIntTypeGet_IgnoreBool = (char)1;
}

void GPIOIntTypeGet_CMockStopIgnore(void)
{
  if(Mock.GPIOIntTypeGet_IgnoreBool)
    Mock.GPIOIntTypeGet_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntTypeGet_CallInstance);
  Mock.GPIOIntTypeGet_IgnoreBool = (char)0;
}

void GPIOIntTypeGet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pin, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntTypeGet_CALL_INSTANCE));
  CMOCK_GPIOIntTypeGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntTypeGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntTypeGet_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntTypeGet_CallInstance, cmock_guts_index);
  Mock.GPIOIntTypeGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntTypeGet(cmock_call_instance, ui32Port, ui8Pin);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void GPIOIntTypeGet_AddCallback(CMOCK_GPIOIntTypeGet_CALLBACK Callback)
{
  Mock.GPIOIntTypeGet_IgnoreBool = (char)0;
  Mock.GPIOIntTypeGet_CallbackBool = (char)1;
  Mock.GPIOIntTypeGet_CallbackFunctionPointer = Callback;
}

void GPIOIntTypeGet_Stub(CMOCK_GPIOIntTypeGet_CALLBACK Callback)
{
  Mock.GPIOIntTypeGet_IgnoreBool = (char)0;
  Mock.GPIOIntTypeGet_CallbackBool = (char)0;
  Mock.GPIOIntTypeGet_CallbackFunctionPointer = Callback;
}

void GPIOPadConfigSet(uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32Strength, uint32_t ui32PadType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPadConfigSet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPadConfigSet);
  cmock_call_instance = (CMOCK_GPIOPadConfigSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPadConfigSet_CallInstance);
  Mock.GPIOPadConfigSet_CallInstance = CMock_Guts_MemNext(Mock.GPIOPadConfigSet_CallInstance);
  if (Mock.GPIOPadConfigSet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPadConfigSet_CallbackBool &&
      Mock.GPIOPadConfigSet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPadConfigSet_CallbackFunctionPointer(ui32Port, ui8Pins, ui32Strength, ui32PadType, Mock.GPIOPadConfigSet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigSet,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigSet,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigSet,CMockString_ui32Strength);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Strength, ui32Strength, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigSet,CMockString_ui32PadType);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32PadType, ui32PadType, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPadConfigSet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPadConfigSet_CallbackFunctionPointer(ui32Port, ui8Pins, ui32Strength, ui32PadType, Mock.GPIOPadConfigSet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPadConfigSet(CMOCK_GPIOPadConfigSet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32Strength, uint32_t ui32PadType);
void CMockExpectParameters_GPIOPadConfigSet(CMOCK_GPIOPadConfigSet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32Strength, uint32_t ui32PadType)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
  cmock_call_instance->Expected_ui32Strength = ui32Strength;
  cmock_call_instance->Expected_ui32PadType = ui32PadType;
}

void GPIOPadConfigSet_CMockIgnore(void)
{
  Mock.GPIOPadConfigSet_IgnoreBool = (char)1;
}

void GPIOPadConfigSet_CMockStopIgnore(void)
{
  Mock.GPIOPadConfigSet_IgnoreBool = (char)0;
}

void GPIOPadConfigSet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins, uint32_t ui32Strength, uint32_t ui32PadType)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPadConfigSet_CALL_INSTANCE));
  CMOCK_GPIOPadConfigSet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPadConfigSet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPadConfigSet_CallInstance = CMock_Guts_MemChain(Mock.GPIOPadConfigSet_CallInstance, cmock_guts_index);
  Mock.GPIOPadConfigSet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPadConfigSet(cmock_call_instance, ui32Port, ui8Pins, ui32Strength, ui32PadType);
}

void GPIOPadConfigSet_AddCallback(CMOCK_GPIOPadConfigSet_CALLBACK Callback)
{
  Mock.GPIOPadConfigSet_IgnoreBool = (char)0;
  Mock.GPIOPadConfigSet_CallbackBool = (char)1;
  Mock.GPIOPadConfigSet_CallbackFunctionPointer = Callback;
}

void GPIOPadConfigSet_Stub(CMOCK_GPIOPadConfigSet_CALLBACK Callback)
{
  Mock.GPIOPadConfigSet_IgnoreBool = (char)0;
  Mock.GPIOPadConfigSet_CallbackBool = (char)0;
  Mock.GPIOPadConfigSet_CallbackFunctionPointer = Callback;
}

void GPIOPadConfigGet(uint32_t ui32Port, uint8_t ui8Pin, uint32_t* pui32Strength, uint32_t* pui32PadType)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPadConfigGet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPadConfigGet);
  cmock_call_instance = (CMOCK_GPIOPadConfigGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPadConfigGet_CallInstance);
  Mock.GPIOPadConfigGet_CallInstance = CMock_Guts_MemNext(Mock.GPIOPadConfigGet_CallInstance);
  if (Mock.GPIOPadConfigGet_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPadConfigGet_CallbackBool &&
      Mock.GPIOPadConfigGet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPadConfigGet_CallbackFunctionPointer(ui32Port, ui8Pin, pui32Strength, pui32PadType, Mock.GPIOPadConfigGet_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigGet,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigGet,CMockString_ui8Pin);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pin, ui8Pin, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigGet,CMockString_pui32Strength);
    if (cmock_call_instance->Expected_pui32Strength == NULL)
      { UNITY_TEST_ASSERT_NULL(pui32Strength, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pui32Strength, pui32Strength, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPadConfigGet,CMockString_pui32PadType);
    if (cmock_call_instance->Expected_pui32PadType == NULL)
      { UNITY_TEST_ASSERT_NULL(pui32PadType, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pui32PadType, pui32PadType, 1, cmock_line, CMockStringMismatch); }
  }
  if (Mock.GPIOPadConfigGet_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPadConfigGet_CallbackFunctionPointer(ui32Port, ui8Pin, pui32Strength, pui32PadType, Mock.GPIOPadConfigGet_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPadConfigGet(CMOCK_GPIOPadConfigGet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pin, uint32_t* pui32Strength, uint32_t* pui32PadType);
void CMockExpectParameters_GPIOPadConfigGet(CMOCK_GPIOPadConfigGet_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pin, uint32_t* pui32Strength, uint32_t* pui32PadType)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pin = ui8Pin;
  cmock_call_instance->Expected_pui32Strength = pui32Strength;
  cmock_call_instance->Expected_pui32PadType = pui32PadType;
}

void GPIOPadConfigGet_CMockIgnore(void)
{
  Mock.GPIOPadConfigGet_IgnoreBool = (char)1;
}

void GPIOPadConfigGet_CMockStopIgnore(void)
{
  Mock.GPIOPadConfigGet_IgnoreBool = (char)0;
}

void GPIOPadConfigGet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pin, uint32_t* pui32Strength, uint32_t* pui32PadType)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPadConfigGet_CALL_INSTANCE));
  CMOCK_GPIOPadConfigGet_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPadConfigGet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPadConfigGet_CallInstance = CMock_Guts_MemChain(Mock.GPIOPadConfigGet_CallInstance, cmock_guts_index);
  Mock.GPIOPadConfigGet_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPadConfigGet(cmock_call_instance, ui32Port, ui8Pin, pui32Strength, pui32PadType);
}

void GPIOPadConfigGet_AddCallback(CMOCK_GPIOPadConfigGet_CALLBACK Callback)
{
  Mock.GPIOPadConfigGet_IgnoreBool = (char)0;
  Mock.GPIOPadConfigGet_CallbackBool = (char)1;
  Mock.GPIOPadConfigGet_CallbackFunctionPointer = Callback;
}

void GPIOPadConfigGet_Stub(CMOCK_GPIOPadConfigGet_CALLBACK Callback)
{
  Mock.GPIOPadConfigGet_IgnoreBool = (char)0;
  Mock.GPIOPadConfigGet_CallbackBool = (char)0;
  Mock.GPIOPadConfigGet_CallbackFunctionPointer = Callback;
}

void GPIOIntEnable(uint32_t ui32Port, uint32_t ui32IntFlags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntEnable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntEnable);
  cmock_call_instance = (CMOCK_GPIOIntEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntEnable_CallInstance);
  Mock.GPIOIntEnable_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntEnable_CallInstance);
  if (Mock.GPIOIntEnable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntEnable_CallbackBool &&
      Mock.GPIOIntEnable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntEnable_CallbackFunctionPointer(ui32Port, ui32IntFlags, Mock.GPIOIntEnable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntEnable,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntEnable,CMockString_ui32IntFlags);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32IntFlags, ui32IntFlags, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntEnable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntEnable_CallbackFunctionPointer(ui32Port, ui32IntFlags, Mock.GPIOIntEnable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntEnable(CMOCK_GPIOIntEnable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32IntFlags);
void CMockExpectParameters_GPIOIntEnable(CMOCK_GPIOIntEnable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32IntFlags)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui32IntFlags = ui32IntFlags;
}

void GPIOIntEnable_CMockIgnore(void)
{
  Mock.GPIOIntEnable_IgnoreBool = (char)1;
}

void GPIOIntEnable_CMockStopIgnore(void)
{
  Mock.GPIOIntEnable_IgnoreBool = (char)0;
}

void GPIOIntEnable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint32_t ui32IntFlags)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntEnable_CALL_INSTANCE));
  CMOCK_GPIOIntEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntEnable_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntEnable_CallInstance, cmock_guts_index);
  Mock.GPIOIntEnable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntEnable(cmock_call_instance, ui32Port, ui32IntFlags);
}

void GPIOIntEnable_AddCallback(CMOCK_GPIOIntEnable_CALLBACK Callback)
{
  Mock.GPIOIntEnable_IgnoreBool = (char)0;
  Mock.GPIOIntEnable_CallbackBool = (char)1;
  Mock.GPIOIntEnable_CallbackFunctionPointer = Callback;
}

void GPIOIntEnable_Stub(CMOCK_GPIOIntEnable_CALLBACK Callback)
{
  Mock.GPIOIntEnable_IgnoreBool = (char)0;
  Mock.GPIOIntEnable_CallbackBool = (char)0;
  Mock.GPIOIntEnable_CallbackFunctionPointer = Callback;
}

void GPIOIntDisable(uint32_t ui32Port, uint32_t ui32IntFlags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntDisable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntDisable);
  cmock_call_instance = (CMOCK_GPIOIntDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntDisable_CallInstance);
  Mock.GPIOIntDisable_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntDisable_CallInstance);
  if (Mock.GPIOIntDisable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntDisable_CallbackBool &&
      Mock.GPIOIntDisable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntDisable_CallbackFunctionPointer(ui32Port, ui32IntFlags, Mock.GPIOIntDisable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntDisable,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntDisable,CMockString_ui32IntFlags);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32IntFlags, ui32IntFlags, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntDisable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntDisable_CallbackFunctionPointer(ui32Port, ui32IntFlags, Mock.GPIOIntDisable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntDisable(CMOCK_GPIOIntDisable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32IntFlags);
void CMockExpectParameters_GPIOIntDisable(CMOCK_GPIOIntDisable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32IntFlags)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui32IntFlags = ui32IntFlags;
}

void GPIOIntDisable_CMockIgnore(void)
{
  Mock.GPIOIntDisable_IgnoreBool = (char)1;
}

void GPIOIntDisable_CMockStopIgnore(void)
{
  Mock.GPIOIntDisable_IgnoreBool = (char)0;
}

void GPIOIntDisable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint32_t ui32IntFlags)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntDisable_CALL_INSTANCE));
  CMOCK_GPIOIntDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntDisable_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntDisable_CallInstance, cmock_guts_index);
  Mock.GPIOIntDisable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntDisable(cmock_call_instance, ui32Port, ui32IntFlags);
}

void GPIOIntDisable_AddCallback(CMOCK_GPIOIntDisable_CALLBACK Callback)
{
  Mock.GPIOIntDisable_IgnoreBool = (char)0;
  Mock.GPIOIntDisable_CallbackBool = (char)1;
  Mock.GPIOIntDisable_CallbackFunctionPointer = Callback;
}

void GPIOIntDisable_Stub(CMOCK_GPIOIntDisable_CALLBACK Callback)
{
  Mock.GPIOIntDisable_IgnoreBool = (char)0;
  Mock.GPIOIntDisable_CallbackBool = (char)0;
  Mock.GPIOIntDisable_CallbackFunctionPointer = Callback;
}

uint32_t GPIOIntStatus(uint32_t ui32Port, bool bMasked)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntStatus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntStatus);
  cmock_call_instance = (CMOCK_GPIOIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntStatus_CallInstance);
  Mock.GPIOIntStatus_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntStatus_CallInstance);
  if (Mock.GPIOIntStatus_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.GPIOIntStatus_FinalReturn;
    Mock.GPIOIntStatus_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.GPIOIntStatus_CallbackBool &&
      Mock.GPIOIntStatus_CallbackFunctionPointer != NULL)
  {
    uint32_t cmock_cb_ret = Mock.GPIOIntStatus_CallbackFunctionPointer(ui32Port, bMasked, Mock.GPIOIntStatus_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntStatus,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntStatus,CMockString_bMasked);
    UNITY_TEST_ASSERT_EQUAL_UINT8(cmock_call_instance->Expected_bMasked, bMasked, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntStatus_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.GPIOIntStatus_CallbackFunctionPointer(ui32Port, bMasked, Mock.GPIOIntStatus_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GPIOIntStatus(CMOCK_GPIOIntStatus_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, bool bMasked);
void CMockExpectParameters_GPIOIntStatus(CMOCK_GPIOIntStatus_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, bool bMasked)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_bMasked = bMasked;
}

void GPIOIntStatus_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntStatus_CALL_INSTANCE));
  CMOCK_GPIOIntStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntStatus_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntStatus_CallInstance, cmock_guts_index);
  Mock.GPIOIntStatus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.GPIOIntStatus_IgnoreBool = (char)1;
}

void GPIOIntStatus_CMockStopIgnore(void)
{
  if(Mock.GPIOIntStatus_IgnoreBool)
    Mock.GPIOIntStatus_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntStatus_CallInstance);
  Mock.GPIOIntStatus_IgnoreBool = (char)0;
}

void GPIOIntStatus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, bool bMasked, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntStatus_CALL_INSTANCE));
  CMOCK_GPIOIntStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntStatus_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntStatus_CallInstance, cmock_guts_index);
  Mock.GPIOIntStatus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntStatus(cmock_call_instance, ui32Port, bMasked);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void GPIOIntStatus_AddCallback(CMOCK_GPIOIntStatus_CALLBACK Callback)
{
  Mock.GPIOIntStatus_IgnoreBool = (char)0;
  Mock.GPIOIntStatus_CallbackBool = (char)1;
  Mock.GPIOIntStatus_CallbackFunctionPointer = Callback;
}

void GPIOIntStatus_Stub(CMOCK_GPIOIntStatus_CALLBACK Callback)
{
  Mock.GPIOIntStatus_IgnoreBool = (char)0;
  Mock.GPIOIntStatus_CallbackBool = (char)0;
  Mock.GPIOIntStatus_CallbackFunctionPointer = Callback;
}

void GPIOIntClear(uint32_t ui32Port, uint32_t ui32IntFlags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntClear_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntClear);
  cmock_call_instance = (CMOCK_GPIOIntClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntClear_CallInstance);
  Mock.GPIOIntClear_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntClear_CallInstance);
  if (Mock.GPIOIntClear_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntClear_CallbackBool &&
      Mock.GPIOIntClear_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntClear_CallbackFunctionPointer(ui32Port, ui32IntFlags, Mock.GPIOIntClear_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntClear,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntClear,CMockString_ui32IntFlags);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32IntFlags, ui32IntFlags, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntClear_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntClear_CallbackFunctionPointer(ui32Port, ui32IntFlags, Mock.GPIOIntClear_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntClear(CMOCK_GPIOIntClear_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32IntFlags);
void CMockExpectParameters_GPIOIntClear(CMOCK_GPIOIntClear_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32IntFlags)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui32IntFlags = ui32IntFlags;
}

void GPIOIntClear_CMockIgnore(void)
{
  Mock.GPIOIntClear_IgnoreBool = (char)1;
}

void GPIOIntClear_CMockStopIgnore(void)
{
  Mock.GPIOIntClear_IgnoreBool = (char)0;
}

void GPIOIntClear_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint32_t ui32IntFlags)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntClear_CALL_INSTANCE));
  CMOCK_GPIOIntClear_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntClear_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntClear_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntClear_CallInstance, cmock_guts_index);
  Mock.GPIOIntClear_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntClear(cmock_call_instance, ui32Port, ui32IntFlags);
}

void GPIOIntClear_AddCallback(CMOCK_GPIOIntClear_CALLBACK Callback)
{
  Mock.GPIOIntClear_IgnoreBool = (char)0;
  Mock.GPIOIntClear_CallbackBool = (char)1;
  Mock.GPIOIntClear_CallbackFunctionPointer = Callback;
}

void GPIOIntClear_Stub(CMOCK_GPIOIntClear_CALLBACK Callback)
{
  Mock.GPIOIntClear_IgnoreBool = (char)0;
  Mock.GPIOIntClear_CallbackBool = (char)0;
  Mock.GPIOIntClear_CallbackFunctionPointer = Callback;
}

void GPIOIntRegister(uint32_t ui32Port, cmock_gpio_func_ptr1 pfnIntHandler)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntRegister_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntRegister);
  cmock_call_instance = (CMOCK_GPIOIntRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntRegister_CallInstance);
  Mock.GPIOIntRegister_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntRegister_CallInstance);
  if (Mock.GPIOIntRegister_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntRegister_CallbackBool &&
      Mock.GPIOIntRegister_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntRegister_CallbackFunctionPointer(ui32Port, pfnIntHandler, Mock.GPIOIntRegister_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntRegister,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntRegister,CMockString_pfnIntHandler);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pfnIntHandler, pfnIntHandler, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntRegister_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntRegister_CallbackFunctionPointer(ui32Port, pfnIntHandler, Mock.GPIOIntRegister_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntRegister(CMOCK_GPIOIntRegister_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, cmock_gpio_func_ptr1 pfnIntHandler);
void CMockExpectParameters_GPIOIntRegister(CMOCK_GPIOIntRegister_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, cmock_gpio_func_ptr1 pfnIntHandler)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  memcpy((void*)(&cmock_call_instance->Expected_pfnIntHandler), (void*)(&pfnIntHandler),
         sizeof(cmock_gpio_func_ptr1[sizeof(pfnIntHandler) == sizeof(cmock_gpio_func_ptr1) ? 1 : -1])); /* add cmock_gpio_func_ptr1 to :treat_as_array if this causes an error */
}

void GPIOIntRegister_CMockIgnore(void)
{
  Mock.GPIOIntRegister_IgnoreBool = (char)1;
}

void GPIOIntRegister_CMockStopIgnore(void)
{
  Mock.GPIOIntRegister_IgnoreBool = (char)0;
}

void GPIOIntRegister_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, cmock_gpio_func_ptr1 pfnIntHandler)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntRegister_CALL_INSTANCE));
  CMOCK_GPIOIntRegister_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntRegister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntRegister_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntRegister_CallInstance, cmock_guts_index);
  Mock.GPIOIntRegister_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntRegister(cmock_call_instance, ui32Port, pfnIntHandler);
}

void GPIOIntRegister_AddCallback(CMOCK_GPIOIntRegister_CALLBACK Callback)
{
  Mock.GPIOIntRegister_IgnoreBool = (char)0;
  Mock.GPIOIntRegister_CallbackBool = (char)1;
  Mock.GPIOIntRegister_CallbackFunctionPointer = Callback;
}

void GPIOIntRegister_Stub(CMOCK_GPIOIntRegister_CALLBACK Callback)
{
  Mock.GPIOIntRegister_IgnoreBool = (char)0;
  Mock.GPIOIntRegister_CallbackBool = (char)0;
  Mock.GPIOIntRegister_CallbackFunctionPointer = Callback;
}

void GPIOIntUnregister(uint32_t ui32Port)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntUnregister_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntUnregister);
  cmock_call_instance = (CMOCK_GPIOIntUnregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntUnregister_CallInstance);
  Mock.GPIOIntUnregister_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntUnregister_CallInstance);
  if (Mock.GPIOIntUnregister_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntUnregister_CallbackBool &&
      Mock.GPIOIntUnregister_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntUnregister_CallbackFunctionPointer(ui32Port, Mock.GPIOIntUnregister_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntUnregister,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntUnregister_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntUnregister_CallbackFunctionPointer(ui32Port, Mock.GPIOIntUnregister_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntUnregister(CMOCK_GPIOIntUnregister_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port);
void CMockExpectParameters_GPIOIntUnregister(CMOCK_GPIOIntUnregister_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
}

void GPIOIntUnregister_CMockIgnore(void)
{
  Mock.GPIOIntUnregister_IgnoreBool = (char)1;
}

void GPIOIntUnregister_CMockStopIgnore(void)
{
  Mock.GPIOIntUnregister_IgnoreBool = (char)0;
}

void GPIOIntUnregister_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntUnregister_CALL_INSTANCE));
  CMOCK_GPIOIntUnregister_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntUnregister_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntUnregister_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntUnregister_CallInstance, cmock_guts_index);
  Mock.GPIOIntUnregister_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntUnregister(cmock_call_instance, ui32Port);
}

void GPIOIntUnregister_AddCallback(CMOCK_GPIOIntUnregister_CALLBACK Callback)
{
  Mock.GPIOIntUnregister_IgnoreBool = (char)0;
  Mock.GPIOIntUnregister_CallbackBool = (char)1;
  Mock.GPIOIntUnregister_CallbackFunctionPointer = Callback;
}

void GPIOIntUnregister_Stub(CMOCK_GPIOIntUnregister_CALLBACK Callback)
{
  Mock.GPIOIntUnregister_IgnoreBool = (char)0;
  Mock.GPIOIntUnregister_CallbackBool = (char)0;
  Mock.GPIOIntUnregister_CallbackFunctionPointer = Callback;
}

void GPIOIntRegisterPin(uint32_t ui32Port, uint32_t ui32Pin, cmock_gpio_func_ptr2 pfnIntHandler)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntRegisterPin_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntRegisterPin);
  cmock_call_instance = (CMOCK_GPIOIntRegisterPin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntRegisterPin_CallInstance);
  Mock.GPIOIntRegisterPin_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntRegisterPin_CallInstance);
  if (Mock.GPIOIntRegisterPin_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntRegisterPin_CallbackBool &&
      Mock.GPIOIntRegisterPin_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntRegisterPin_CallbackFunctionPointer(ui32Port, ui32Pin, pfnIntHandler, Mock.GPIOIntRegisterPin_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntRegisterPin,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntRegisterPin,CMockString_ui32Pin);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Pin, ui32Pin, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntRegisterPin,CMockString_pfnIntHandler);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pfnIntHandler, pfnIntHandler, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntRegisterPin_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntRegisterPin_CallbackFunctionPointer(ui32Port, ui32Pin, pfnIntHandler, Mock.GPIOIntRegisterPin_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntRegisterPin(CMOCK_GPIOIntRegisterPin_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32Pin, cmock_gpio_func_ptr2 pfnIntHandler);
void CMockExpectParameters_GPIOIntRegisterPin(CMOCK_GPIOIntRegisterPin_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32Pin, cmock_gpio_func_ptr2 pfnIntHandler)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui32Pin = ui32Pin;
  memcpy((void*)(&cmock_call_instance->Expected_pfnIntHandler), (void*)(&pfnIntHandler),
         sizeof(cmock_gpio_func_ptr2[sizeof(pfnIntHandler) == sizeof(cmock_gpio_func_ptr2) ? 1 : -1])); /* add cmock_gpio_func_ptr2 to :treat_as_array if this causes an error */
}

void GPIOIntRegisterPin_CMockIgnore(void)
{
  Mock.GPIOIntRegisterPin_IgnoreBool = (char)1;
}

void GPIOIntRegisterPin_CMockStopIgnore(void)
{
  Mock.GPIOIntRegisterPin_IgnoreBool = (char)0;
}

void GPIOIntRegisterPin_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint32_t ui32Pin, cmock_gpio_func_ptr2 pfnIntHandler)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntRegisterPin_CALL_INSTANCE));
  CMOCK_GPIOIntRegisterPin_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntRegisterPin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntRegisterPin_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntRegisterPin_CallInstance, cmock_guts_index);
  Mock.GPIOIntRegisterPin_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntRegisterPin(cmock_call_instance, ui32Port, ui32Pin, pfnIntHandler);
}

void GPIOIntRegisterPin_AddCallback(CMOCK_GPIOIntRegisterPin_CALLBACK Callback)
{
  Mock.GPIOIntRegisterPin_IgnoreBool = (char)0;
  Mock.GPIOIntRegisterPin_CallbackBool = (char)1;
  Mock.GPIOIntRegisterPin_CallbackFunctionPointer = Callback;
}

void GPIOIntRegisterPin_Stub(CMOCK_GPIOIntRegisterPin_CALLBACK Callback)
{
  Mock.GPIOIntRegisterPin_IgnoreBool = (char)0;
  Mock.GPIOIntRegisterPin_CallbackBool = (char)0;
  Mock.GPIOIntRegisterPin_CallbackFunctionPointer = Callback;
}

void GPIOIntUnregisterPin(uint32_t ui32Port, uint32_t ui32Pin)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOIntUnregisterPin);
  cmock_call_instance = (CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOIntUnregisterPin_CallInstance);
  Mock.GPIOIntUnregisterPin_CallInstance = CMock_Guts_MemNext(Mock.GPIOIntUnregisterPin_CallInstance);
  if (Mock.GPIOIntUnregisterPin_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOIntUnregisterPin_CallbackBool &&
      Mock.GPIOIntUnregisterPin_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntUnregisterPin_CallbackFunctionPointer(ui32Port, ui32Pin, Mock.GPIOIntUnregisterPin_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntUnregisterPin,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOIntUnregisterPin,CMockString_ui32Pin);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Pin, ui32Pin, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOIntUnregisterPin_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOIntUnregisterPin_CallbackFunctionPointer(ui32Port, ui32Pin, Mock.GPIOIntUnregisterPin_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOIntUnregisterPin(CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32Pin);
void CMockExpectParameters_GPIOIntUnregisterPin(CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint32_t ui32Pin)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui32Pin = ui32Pin;
}

void GPIOIntUnregisterPin_CMockIgnore(void)
{
  Mock.GPIOIntUnregisterPin_IgnoreBool = (char)1;
}

void GPIOIntUnregisterPin_CMockStopIgnore(void)
{
  Mock.GPIOIntUnregisterPin_IgnoreBool = (char)0;
}

void GPIOIntUnregisterPin_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint32_t ui32Pin)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE));
  CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOIntUnregisterPin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOIntUnregisterPin_CallInstance = CMock_Guts_MemChain(Mock.GPIOIntUnregisterPin_CallInstance, cmock_guts_index);
  Mock.GPIOIntUnregisterPin_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOIntUnregisterPin(cmock_call_instance, ui32Port, ui32Pin);
}

void GPIOIntUnregisterPin_AddCallback(CMOCK_GPIOIntUnregisterPin_CALLBACK Callback)
{
  Mock.GPIOIntUnregisterPin_IgnoreBool = (char)0;
  Mock.GPIOIntUnregisterPin_CallbackBool = (char)1;
  Mock.GPIOIntUnregisterPin_CallbackFunctionPointer = Callback;
}

void GPIOIntUnregisterPin_Stub(CMOCK_GPIOIntUnregisterPin_CALLBACK Callback)
{
  Mock.GPIOIntUnregisterPin_IgnoreBool = (char)0;
  Mock.GPIOIntUnregisterPin_CallbackBool = (char)0;
  Mock.GPIOIntUnregisterPin_CallbackFunctionPointer = Callback;
}

int32_t GPIOPinRead(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinRead_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinRead);
  cmock_call_instance = (CMOCK_GPIOPinRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinRead_CallInstance);
  Mock.GPIOPinRead_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinRead_CallInstance);
  if (Mock.GPIOPinRead_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.GPIOPinRead_FinalReturn;
    Mock.GPIOPinRead_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.GPIOPinRead_CallbackBool &&
      Mock.GPIOPinRead_CallbackFunctionPointer != NULL)
  {
    int32_t cmock_cb_ret = Mock.GPIOPinRead_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinRead_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinRead,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinRead,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinRead_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.GPIOPinRead_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinRead_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GPIOPinRead(CMOCK_GPIOPinRead_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinRead(CMOCK_GPIOPinRead_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinRead_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinRead_CALL_INSTANCE));
  CMOCK_GPIOPinRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinRead_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinRead_CallInstance, cmock_guts_index);
  Mock.GPIOPinRead_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.GPIOPinRead_IgnoreBool = (char)1;
}

void GPIOPinRead_CMockStopIgnore(void)
{
  if(Mock.GPIOPinRead_IgnoreBool)
    Mock.GPIOPinRead_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinRead_CallInstance);
  Mock.GPIOPinRead_IgnoreBool = (char)0;
}

void GPIOPinRead_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins, int32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinRead_CALL_INSTANCE));
  CMOCK_GPIOPinRead_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinRead_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinRead_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinRead_CallInstance, cmock_guts_index);
  Mock.GPIOPinRead_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinRead(cmock_call_instance, ui32Port, ui8Pins);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void GPIOPinRead_AddCallback(CMOCK_GPIOPinRead_CALLBACK Callback)
{
  Mock.GPIOPinRead_IgnoreBool = (char)0;
  Mock.GPIOPinRead_CallbackBool = (char)1;
  Mock.GPIOPinRead_CallbackFunctionPointer = Callback;
}

void GPIOPinRead_Stub(CMOCK_GPIOPinRead_CALLBACK Callback)
{
  Mock.GPIOPinRead_IgnoreBool = (char)0;
  Mock.GPIOPinRead_CallbackBool = (char)0;
  Mock.GPIOPinRead_CallbackFunctionPointer = Callback;
}

void GPIOPinWrite(uint32_t ui32Port, uint8_t ui8Pins, uint8_t ui8Val)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinWrite_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinWrite);
  cmock_call_instance = (CMOCK_GPIOPinWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinWrite_CallInstance);
  Mock.GPIOPinWrite_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinWrite_CallInstance);
  if (Mock.GPIOPinWrite_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinWrite_CallbackBool &&
      Mock.GPIOPinWrite_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinWrite_CallbackFunctionPointer(ui32Port, ui8Pins, ui8Val, Mock.GPIOPinWrite_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinWrite,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinWrite,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinWrite,CMockString_ui8Val);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Val, ui8Val, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinWrite_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinWrite_CallbackFunctionPointer(ui32Port, ui8Pins, ui8Val, Mock.GPIOPinWrite_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinWrite(CMOCK_GPIOPinWrite_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint8_t ui8Val);
void CMockExpectParameters_GPIOPinWrite(CMOCK_GPIOPinWrite_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins, uint8_t ui8Val)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
  cmock_call_instance->Expected_ui8Val = ui8Val;
}

void GPIOPinWrite_CMockIgnore(void)
{
  Mock.GPIOPinWrite_IgnoreBool = (char)1;
}

void GPIOPinWrite_CMockStopIgnore(void)
{
  Mock.GPIOPinWrite_IgnoreBool = (char)0;
}

void GPIOPinWrite_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins, uint8_t ui8Val)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinWrite_CALL_INSTANCE));
  CMOCK_GPIOPinWrite_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinWrite_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinWrite_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinWrite_CallInstance, cmock_guts_index);
  Mock.GPIOPinWrite_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinWrite(cmock_call_instance, ui32Port, ui8Pins, ui8Val);
}

void GPIOPinWrite_AddCallback(CMOCK_GPIOPinWrite_CALLBACK Callback)
{
  Mock.GPIOPinWrite_IgnoreBool = (char)0;
  Mock.GPIOPinWrite_CallbackBool = (char)1;
  Mock.GPIOPinWrite_CallbackFunctionPointer = Callback;
}

void GPIOPinWrite_Stub(CMOCK_GPIOPinWrite_CALLBACK Callback)
{
  Mock.GPIOPinWrite_IgnoreBool = (char)0;
  Mock.GPIOPinWrite_CallbackBool = (char)0;
  Mock.GPIOPinWrite_CallbackFunctionPointer = Callback;
}

void GPIOPinConfigure(uint32_t ui32PinConfig)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinConfigure_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinConfigure);
  cmock_call_instance = (CMOCK_GPIOPinConfigure_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinConfigure_CallInstance);
  Mock.GPIOPinConfigure_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinConfigure_CallInstance);
  if (Mock.GPIOPinConfigure_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinConfigure_CallbackBool &&
      Mock.GPIOPinConfigure_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinConfigure_CallbackFunctionPointer(ui32PinConfig, Mock.GPIOPinConfigure_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinConfigure,CMockString_ui32PinConfig);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32PinConfig, ui32PinConfig, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinConfigure_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinConfigure_CallbackFunctionPointer(ui32PinConfig, Mock.GPIOPinConfigure_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinConfigure(CMOCK_GPIOPinConfigure_CALL_INSTANCE* cmock_call_instance, uint32_t ui32PinConfig);
void CMockExpectParameters_GPIOPinConfigure(CMOCK_GPIOPinConfigure_CALL_INSTANCE* cmock_call_instance, uint32_t ui32PinConfig)
{
  cmock_call_instance->Expected_ui32PinConfig = ui32PinConfig;
}

void GPIOPinConfigure_CMockIgnore(void)
{
  Mock.GPIOPinConfigure_IgnoreBool = (char)1;
}

void GPIOPinConfigure_CMockStopIgnore(void)
{
  Mock.GPIOPinConfigure_IgnoreBool = (char)0;
}

void GPIOPinConfigure_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32PinConfig)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinConfigure_CALL_INSTANCE));
  CMOCK_GPIOPinConfigure_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinConfigure_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinConfigure_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinConfigure_CallInstance, cmock_guts_index);
  Mock.GPIOPinConfigure_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinConfigure(cmock_call_instance, ui32PinConfig);
}

void GPIOPinConfigure_AddCallback(CMOCK_GPIOPinConfigure_CALLBACK Callback)
{
  Mock.GPIOPinConfigure_IgnoreBool = (char)0;
  Mock.GPIOPinConfigure_CallbackBool = (char)1;
  Mock.GPIOPinConfigure_CallbackFunctionPointer = Callback;
}

void GPIOPinConfigure_Stub(CMOCK_GPIOPinConfigure_CALLBACK Callback)
{
  Mock.GPIOPinConfigure_IgnoreBool = (char)0;
  Mock.GPIOPinConfigure_CallbackBool = (char)0;
  Mock.GPIOPinConfigure_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeADC(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeADC_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeADC);
  cmock_call_instance = (CMOCK_GPIOPinTypeADC_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeADC_CallInstance);
  Mock.GPIOPinTypeADC_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeADC_CallInstance);
  if (Mock.GPIOPinTypeADC_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeADC_CallbackBool &&
      Mock.GPIOPinTypeADC_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeADC_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeADC_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeADC,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeADC,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeADC_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeADC_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeADC_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeADC(CMOCK_GPIOPinTypeADC_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeADC(CMOCK_GPIOPinTypeADC_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeADC_CMockIgnore(void)
{
  Mock.GPIOPinTypeADC_IgnoreBool = (char)1;
}

void GPIOPinTypeADC_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeADC_IgnoreBool = (char)0;
}

void GPIOPinTypeADC_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeADC_CALL_INSTANCE));
  CMOCK_GPIOPinTypeADC_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeADC_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeADC_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeADC_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeADC_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeADC(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeADC_AddCallback(CMOCK_GPIOPinTypeADC_CALLBACK Callback)
{
  Mock.GPIOPinTypeADC_IgnoreBool = (char)0;
  Mock.GPIOPinTypeADC_CallbackBool = (char)1;
  Mock.GPIOPinTypeADC_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeADC_Stub(CMOCK_GPIOPinTypeADC_CALLBACK Callback)
{
  Mock.GPIOPinTypeADC_IgnoreBool = (char)0;
  Mock.GPIOPinTypeADC_CallbackBool = (char)0;
  Mock.GPIOPinTypeADC_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeCAN(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeCAN_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeCAN);
  cmock_call_instance = (CMOCK_GPIOPinTypeCAN_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeCAN_CallInstance);
  Mock.GPIOPinTypeCAN_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeCAN_CallInstance);
  if (Mock.GPIOPinTypeCAN_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeCAN_CallbackBool &&
      Mock.GPIOPinTypeCAN_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeCAN_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeCAN_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeCAN,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeCAN,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeCAN_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeCAN_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeCAN_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeCAN(CMOCK_GPIOPinTypeCAN_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeCAN(CMOCK_GPIOPinTypeCAN_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeCAN_CMockIgnore(void)
{
  Mock.GPIOPinTypeCAN_IgnoreBool = (char)1;
}

void GPIOPinTypeCAN_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeCAN_IgnoreBool = (char)0;
}

void GPIOPinTypeCAN_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeCAN_CALL_INSTANCE));
  CMOCK_GPIOPinTypeCAN_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeCAN_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeCAN_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeCAN_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeCAN_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeCAN(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeCAN_AddCallback(CMOCK_GPIOPinTypeCAN_CALLBACK Callback)
{
  Mock.GPIOPinTypeCAN_IgnoreBool = (char)0;
  Mock.GPIOPinTypeCAN_CallbackBool = (char)1;
  Mock.GPIOPinTypeCAN_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeCAN_Stub(CMOCK_GPIOPinTypeCAN_CALLBACK Callback)
{
  Mock.GPIOPinTypeCAN_IgnoreBool = (char)0;
  Mock.GPIOPinTypeCAN_CallbackBool = (char)0;
  Mock.GPIOPinTypeCAN_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeComparator(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeComparator_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeComparator);
  cmock_call_instance = (CMOCK_GPIOPinTypeComparator_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeComparator_CallInstance);
  Mock.GPIOPinTypeComparator_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeComparator_CallInstance);
  if (Mock.GPIOPinTypeComparator_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeComparator_CallbackBool &&
      Mock.GPIOPinTypeComparator_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeComparator_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeComparator_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeComparator,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeComparator,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeComparator_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeComparator_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeComparator_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeComparator(CMOCK_GPIOPinTypeComparator_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeComparator(CMOCK_GPIOPinTypeComparator_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeComparator_CMockIgnore(void)
{
  Mock.GPIOPinTypeComparator_IgnoreBool = (char)1;
}

void GPIOPinTypeComparator_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeComparator_IgnoreBool = (char)0;
}

void GPIOPinTypeComparator_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeComparator_CALL_INSTANCE));
  CMOCK_GPIOPinTypeComparator_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeComparator_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeComparator_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeComparator_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeComparator_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeComparator(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeComparator_AddCallback(CMOCK_GPIOPinTypeComparator_CALLBACK Callback)
{
  Mock.GPIOPinTypeComparator_IgnoreBool = (char)0;
  Mock.GPIOPinTypeComparator_CallbackBool = (char)1;
  Mock.GPIOPinTypeComparator_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeComparator_Stub(CMOCK_GPIOPinTypeComparator_CALLBACK Callback)
{
  Mock.GPIOPinTypeComparator_IgnoreBool = (char)0;
  Mock.GPIOPinTypeComparator_CallbackBool = (char)0;
  Mock.GPIOPinTypeComparator_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeComparatorOutput(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeComparatorOutput);
  cmock_call_instance = (CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeComparatorOutput_CallInstance);
  Mock.GPIOPinTypeComparatorOutput_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeComparatorOutput_CallInstance);
  if (Mock.GPIOPinTypeComparatorOutput_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeComparatorOutput_CallbackBool &&
      Mock.GPIOPinTypeComparatorOutput_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeComparatorOutput_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeComparatorOutput_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeComparatorOutput,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeComparatorOutput,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeComparatorOutput_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeComparatorOutput_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeComparatorOutput_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeComparatorOutput(CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeComparatorOutput(CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeComparatorOutput_CMockIgnore(void)
{
  Mock.GPIOPinTypeComparatorOutput_IgnoreBool = (char)1;
}

void GPIOPinTypeComparatorOutput_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeComparatorOutput_IgnoreBool = (char)0;
}

void GPIOPinTypeComparatorOutput_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE));
  CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeComparatorOutput_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeComparatorOutput_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeComparatorOutput_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeComparatorOutput_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeComparatorOutput(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeComparatorOutput_AddCallback(CMOCK_GPIOPinTypeComparatorOutput_CALLBACK Callback)
{
  Mock.GPIOPinTypeComparatorOutput_IgnoreBool = (char)0;
  Mock.GPIOPinTypeComparatorOutput_CallbackBool = (char)1;
  Mock.GPIOPinTypeComparatorOutput_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeComparatorOutput_Stub(CMOCK_GPIOPinTypeComparatorOutput_CALLBACK Callback)
{
  Mock.GPIOPinTypeComparatorOutput_IgnoreBool = (char)0;
  Mock.GPIOPinTypeComparatorOutput_CallbackBool = (char)0;
  Mock.GPIOPinTypeComparatorOutput_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeDIVSCLK(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeDIVSCLK);
  cmock_call_instance = (CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeDIVSCLK_CallInstance);
  Mock.GPIOPinTypeDIVSCLK_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeDIVSCLK_CallInstance);
  if (Mock.GPIOPinTypeDIVSCLK_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeDIVSCLK_CallbackBool &&
      Mock.GPIOPinTypeDIVSCLK_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeDIVSCLK_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeDIVSCLK_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeDIVSCLK,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeDIVSCLK,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeDIVSCLK_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeDIVSCLK_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeDIVSCLK_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeDIVSCLK(CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeDIVSCLK(CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeDIVSCLK_CMockIgnore(void)
{
  Mock.GPIOPinTypeDIVSCLK_IgnoreBool = (char)1;
}

void GPIOPinTypeDIVSCLK_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeDIVSCLK_IgnoreBool = (char)0;
}

void GPIOPinTypeDIVSCLK_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE));
  CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeDIVSCLK_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeDIVSCLK_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeDIVSCLK_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeDIVSCLK_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeDIVSCLK(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeDIVSCLK_AddCallback(CMOCK_GPIOPinTypeDIVSCLK_CALLBACK Callback)
{
  Mock.GPIOPinTypeDIVSCLK_IgnoreBool = (char)0;
  Mock.GPIOPinTypeDIVSCLK_CallbackBool = (char)1;
  Mock.GPIOPinTypeDIVSCLK_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeDIVSCLK_Stub(CMOCK_GPIOPinTypeDIVSCLK_CALLBACK Callback)
{
  Mock.GPIOPinTypeDIVSCLK_IgnoreBool = (char)0;
  Mock.GPIOPinTypeDIVSCLK_CallbackBool = (char)0;
  Mock.GPIOPinTypeDIVSCLK_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeEPI(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeEPI_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeEPI);
  cmock_call_instance = (CMOCK_GPIOPinTypeEPI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeEPI_CallInstance);
  Mock.GPIOPinTypeEPI_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeEPI_CallInstance);
  if (Mock.GPIOPinTypeEPI_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeEPI_CallbackBool &&
      Mock.GPIOPinTypeEPI_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeEPI_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeEPI_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeEPI,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeEPI,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeEPI_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeEPI_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeEPI_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeEPI(CMOCK_GPIOPinTypeEPI_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeEPI(CMOCK_GPIOPinTypeEPI_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeEPI_CMockIgnore(void)
{
  Mock.GPIOPinTypeEPI_IgnoreBool = (char)1;
}

void GPIOPinTypeEPI_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeEPI_IgnoreBool = (char)0;
}

void GPIOPinTypeEPI_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeEPI_CALL_INSTANCE));
  CMOCK_GPIOPinTypeEPI_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeEPI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeEPI_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeEPI_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeEPI_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeEPI(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeEPI_AddCallback(CMOCK_GPIOPinTypeEPI_CALLBACK Callback)
{
  Mock.GPIOPinTypeEPI_IgnoreBool = (char)0;
  Mock.GPIOPinTypeEPI_CallbackBool = (char)1;
  Mock.GPIOPinTypeEPI_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeEPI_Stub(CMOCK_GPIOPinTypeEPI_CALLBACK Callback)
{
  Mock.GPIOPinTypeEPI_IgnoreBool = (char)0;
  Mock.GPIOPinTypeEPI_CallbackBool = (char)0;
  Mock.GPIOPinTypeEPI_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeEthernetLED(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeEthernetLED);
  cmock_call_instance = (CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeEthernetLED_CallInstance);
  Mock.GPIOPinTypeEthernetLED_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeEthernetLED_CallInstance);
  if (Mock.GPIOPinTypeEthernetLED_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeEthernetLED_CallbackBool &&
      Mock.GPIOPinTypeEthernetLED_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeEthernetLED_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeEthernetLED_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeEthernetLED,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeEthernetLED,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeEthernetLED_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeEthernetLED_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeEthernetLED_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeEthernetLED(CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeEthernetLED(CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeEthernetLED_CMockIgnore(void)
{
  Mock.GPIOPinTypeEthernetLED_IgnoreBool = (char)1;
}

void GPIOPinTypeEthernetLED_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeEthernetLED_IgnoreBool = (char)0;
}

void GPIOPinTypeEthernetLED_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE));
  CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeEthernetLED_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeEthernetLED_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeEthernetLED_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeEthernetLED_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeEthernetLED(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeEthernetLED_AddCallback(CMOCK_GPIOPinTypeEthernetLED_CALLBACK Callback)
{
  Mock.GPIOPinTypeEthernetLED_IgnoreBool = (char)0;
  Mock.GPIOPinTypeEthernetLED_CallbackBool = (char)1;
  Mock.GPIOPinTypeEthernetLED_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeEthernetLED_Stub(CMOCK_GPIOPinTypeEthernetLED_CALLBACK Callback)
{
  Mock.GPIOPinTypeEthernetLED_IgnoreBool = (char)0;
  Mock.GPIOPinTypeEthernetLED_CallbackBool = (char)0;
  Mock.GPIOPinTypeEthernetLED_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeEthernetMII(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeEthernetMII);
  cmock_call_instance = (CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeEthernetMII_CallInstance);
  Mock.GPIOPinTypeEthernetMII_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeEthernetMII_CallInstance);
  if (Mock.GPIOPinTypeEthernetMII_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeEthernetMII_CallbackBool &&
      Mock.GPIOPinTypeEthernetMII_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeEthernetMII_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeEthernetMII_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeEthernetMII,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeEthernetMII,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeEthernetMII_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeEthernetMII_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeEthernetMII_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeEthernetMII(CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeEthernetMII(CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeEthernetMII_CMockIgnore(void)
{
  Mock.GPIOPinTypeEthernetMII_IgnoreBool = (char)1;
}

void GPIOPinTypeEthernetMII_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeEthernetMII_IgnoreBool = (char)0;
}

void GPIOPinTypeEthernetMII_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE));
  CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeEthernetMII_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeEthernetMII_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeEthernetMII_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeEthernetMII_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeEthernetMII(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeEthernetMII_AddCallback(CMOCK_GPIOPinTypeEthernetMII_CALLBACK Callback)
{
  Mock.GPIOPinTypeEthernetMII_IgnoreBool = (char)0;
  Mock.GPIOPinTypeEthernetMII_CallbackBool = (char)1;
  Mock.GPIOPinTypeEthernetMII_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeEthernetMII_Stub(CMOCK_GPIOPinTypeEthernetMII_CALLBACK Callback)
{
  Mock.GPIOPinTypeEthernetMII_IgnoreBool = (char)0;
  Mock.GPIOPinTypeEthernetMII_CallbackBool = (char)0;
  Mock.GPIOPinTypeEthernetMII_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeGPIOInput(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeGPIOInput);
  cmock_call_instance = (CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeGPIOInput_CallInstance);
  Mock.GPIOPinTypeGPIOInput_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeGPIOInput_CallInstance);
  if (Mock.GPIOPinTypeGPIOInput_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeGPIOInput_CallbackBool &&
      Mock.GPIOPinTypeGPIOInput_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeGPIOInput_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeGPIOInput_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeGPIOInput,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeGPIOInput,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeGPIOInput_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeGPIOInput_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeGPIOInput_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeGPIOInput(CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeGPIOInput(CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeGPIOInput_CMockIgnore(void)
{
  Mock.GPIOPinTypeGPIOInput_IgnoreBool = (char)1;
}

void GPIOPinTypeGPIOInput_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeGPIOInput_IgnoreBool = (char)0;
}

void GPIOPinTypeGPIOInput_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE));
  CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeGPIOInput_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeGPIOInput_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeGPIOInput_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeGPIOInput_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeGPIOInput(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeGPIOInput_AddCallback(CMOCK_GPIOPinTypeGPIOInput_CALLBACK Callback)
{
  Mock.GPIOPinTypeGPIOInput_IgnoreBool = (char)0;
  Mock.GPIOPinTypeGPIOInput_CallbackBool = (char)1;
  Mock.GPIOPinTypeGPIOInput_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeGPIOInput_Stub(CMOCK_GPIOPinTypeGPIOInput_CALLBACK Callback)
{
  Mock.GPIOPinTypeGPIOInput_IgnoreBool = (char)0;
  Mock.GPIOPinTypeGPIOInput_CallbackBool = (char)0;
  Mock.GPIOPinTypeGPIOInput_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeGPIOOutput(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeGPIOOutput);
  cmock_call_instance = (CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeGPIOOutput_CallInstance);
  Mock.GPIOPinTypeGPIOOutput_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeGPIOOutput_CallInstance);
  if (Mock.GPIOPinTypeGPIOOutput_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeGPIOOutput_CallbackBool &&
      Mock.GPIOPinTypeGPIOOutput_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeGPIOOutput_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeGPIOOutput_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeGPIOOutput,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeGPIOOutput,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeGPIOOutput_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeGPIOOutput_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeGPIOOutput_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeGPIOOutput(CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeGPIOOutput(CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeGPIOOutput_CMockIgnore(void)
{
  Mock.GPIOPinTypeGPIOOutput_IgnoreBool = (char)1;
}

void GPIOPinTypeGPIOOutput_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeGPIOOutput_IgnoreBool = (char)0;
}

void GPIOPinTypeGPIOOutput_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE));
  CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeGPIOOutput_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeGPIOOutput_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeGPIOOutput_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeGPIOOutput_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeGPIOOutput(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeGPIOOutput_AddCallback(CMOCK_GPIOPinTypeGPIOOutput_CALLBACK Callback)
{
  Mock.GPIOPinTypeGPIOOutput_IgnoreBool = (char)0;
  Mock.GPIOPinTypeGPIOOutput_CallbackBool = (char)1;
  Mock.GPIOPinTypeGPIOOutput_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeGPIOOutput_Stub(CMOCK_GPIOPinTypeGPIOOutput_CALLBACK Callback)
{
  Mock.GPIOPinTypeGPIOOutput_IgnoreBool = (char)0;
  Mock.GPIOPinTypeGPIOOutput_CallbackBool = (char)0;
  Mock.GPIOPinTypeGPIOOutput_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeGPIOOutputOD(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeGPIOOutputOD);
  cmock_call_instance = (CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeGPIOOutputOD_CallInstance);
  Mock.GPIOPinTypeGPIOOutputOD_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeGPIOOutputOD_CallInstance);
  if (Mock.GPIOPinTypeGPIOOutputOD_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeGPIOOutputOD_CallbackBool &&
      Mock.GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeGPIOOutputOD_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeGPIOOutputOD,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeGPIOOutputOD,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeGPIOOutputOD_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeGPIOOutputOD(CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeGPIOOutputOD(CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeGPIOOutputOD_CMockIgnore(void)
{
  Mock.GPIOPinTypeGPIOOutputOD_IgnoreBool = (char)1;
}

void GPIOPinTypeGPIOOutputOD_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeGPIOOutputOD_IgnoreBool = (char)0;
}

void GPIOPinTypeGPIOOutputOD_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE));
  CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeGPIOOutputOD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeGPIOOutputOD_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeGPIOOutputOD_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeGPIOOutputOD_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeGPIOOutputOD(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeGPIOOutputOD_AddCallback(CMOCK_GPIOPinTypeGPIOOutputOD_CALLBACK Callback)
{
  Mock.GPIOPinTypeGPIOOutputOD_IgnoreBool = (char)0;
  Mock.GPIOPinTypeGPIOOutputOD_CallbackBool = (char)1;
  Mock.GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeGPIOOutputOD_Stub(CMOCK_GPIOPinTypeGPIOOutputOD_CALLBACK Callback)
{
  Mock.GPIOPinTypeGPIOOutputOD_IgnoreBool = (char)0;
  Mock.GPIOPinTypeGPIOOutputOD_CallbackBool = (char)0;
  Mock.GPIOPinTypeGPIOOutputOD_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeHibernateRTCCLK(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeHibernateRTCCLK);
  cmock_call_instance = (CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeHibernateRTCCLK_CallInstance);
  Mock.GPIOPinTypeHibernateRTCCLK_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeHibernateRTCCLK_CallInstance);
  if (Mock.GPIOPinTypeHibernateRTCCLK_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeHibernateRTCCLK_CallbackBool &&
      Mock.GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeHibernateRTCCLK_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeHibernateRTCCLK,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeHibernateRTCCLK,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeHibernateRTCCLK_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeHibernateRTCCLK(CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeHibernateRTCCLK(CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeHibernateRTCCLK_CMockIgnore(void)
{
  Mock.GPIOPinTypeHibernateRTCCLK_IgnoreBool = (char)1;
}

void GPIOPinTypeHibernateRTCCLK_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeHibernateRTCCLK_IgnoreBool = (char)0;
}

void GPIOPinTypeHibernateRTCCLK_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE));
  CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeHibernateRTCCLK_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeHibernateRTCCLK_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeHibernateRTCCLK_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeHibernateRTCCLK_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeHibernateRTCCLK(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeHibernateRTCCLK_AddCallback(CMOCK_GPIOPinTypeHibernateRTCCLK_CALLBACK Callback)
{
  Mock.GPIOPinTypeHibernateRTCCLK_IgnoreBool = (char)0;
  Mock.GPIOPinTypeHibernateRTCCLK_CallbackBool = (char)1;
  Mock.GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeHibernateRTCCLK_Stub(CMOCK_GPIOPinTypeHibernateRTCCLK_CALLBACK Callback)
{
  Mock.GPIOPinTypeHibernateRTCCLK_IgnoreBool = (char)0;
  Mock.GPIOPinTypeHibernateRTCCLK_CallbackBool = (char)0;
  Mock.GPIOPinTypeHibernateRTCCLK_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeI2C(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeI2C_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeI2C);
  cmock_call_instance = (CMOCK_GPIOPinTypeI2C_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeI2C_CallInstance);
  Mock.GPIOPinTypeI2C_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeI2C_CallInstance);
  if (Mock.GPIOPinTypeI2C_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeI2C_CallbackBool &&
      Mock.GPIOPinTypeI2C_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeI2C_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeI2C_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeI2C,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeI2C,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeI2C_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeI2C_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeI2C_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeI2C(CMOCK_GPIOPinTypeI2C_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeI2C(CMOCK_GPIOPinTypeI2C_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeI2C_CMockIgnore(void)
{
  Mock.GPIOPinTypeI2C_IgnoreBool = (char)1;
}

void GPIOPinTypeI2C_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeI2C_IgnoreBool = (char)0;
}

void GPIOPinTypeI2C_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeI2C_CALL_INSTANCE));
  CMOCK_GPIOPinTypeI2C_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeI2C_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeI2C_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeI2C_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeI2C_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeI2C(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeI2C_AddCallback(CMOCK_GPIOPinTypeI2C_CALLBACK Callback)
{
  Mock.GPIOPinTypeI2C_IgnoreBool = (char)0;
  Mock.GPIOPinTypeI2C_CallbackBool = (char)1;
  Mock.GPIOPinTypeI2C_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeI2C_Stub(CMOCK_GPIOPinTypeI2C_CALLBACK Callback)
{
  Mock.GPIOPinTypeI2C_IgnoreBool = (char)0;
  Mock.GPIOPinTypeI2C_CallbackBool = (char)0;
  Mock.GPIOPinTypeI2C_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeI2CSCL(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeI2CSCL);
  cmock_call_instance = (CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeI2CSCL_CallInstance);
  Mock.GPIOPinTypeI2CSCL_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeI2CSCL_CallInstance);
  if (Mock.GPIOPinTypeI2CSCL_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeI2CSCL_CallbackBool &&
      Mock.GPIOPinTypeI2CSCL_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeI2CSCL_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeI2CSCL_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeI2CSCL,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeI2CSCL,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeI2CSCL_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeI2CSCL_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeI2CSCL_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeI2CSCL(CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeI2CSCL(CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeI2CSCL_CMockIgnore(void)
{
  Mock.GPIOPinTypeI2CSCL_IgnoreBool = (char)1;
}

void GPIOPinTypeI2CSCL_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeI2CSCL_IgnoreBool = (char)0;
}

void GPIOPinTypeI2CSCL_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE));
  CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeI2CSCL_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeI2CSCL_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeI2CSCL_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeI2CSCL_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeI2CSCL(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeI2CSCL_AddCallback(CMOCK_GPIOPinTypeI2CSCL_CALLBACK Callback)
{
  Mock.GPIOPinTypeI2CSCL_IgnoreBool = (char)0;
  Mock.GPIOPinTypeI2CSCL_CallbackBool = (char)1;
  Mock.GPIOPinTypeI2CSCL_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeI2CSCL_Stub(CMOCK_GPIOPinTypeI2CSCL_CALLBACK Callback)
{
  Mock.GPIOPinTypeI2CSCL_IgnoreBool = (char)0;
  Mock.GPIOPinTypeI2CSCL_CallbackBool = (char)0;
  Mock.GPIOPinTypeI2CSCL_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeLCD(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeLCD_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeLCD);
  cmock_call_instance = (CMOCK_GPIOPinTypeLCD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeLCD_CallInstance);
  Mock.GPIOPinTypeLCD_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeLCD_CallInstance);
  if (Mock.GPIOPinTypeLCD_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeLCD_CallbackBool &&
      Mock.GPIOPinTypeLCD_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeLCD_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeLCD_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeLCD,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeLCD,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeLCD_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeLCD_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeLCD_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeLCD(CMOCK_GPIOPinTypeLCD_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeLCD(CMOCK_GPIOPinTypeLCD_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeLCD_CMockIgnore(void)
{
  Mock.GPIOPinTypeLCD_IgnoreBool = (char)1;
}

void GPIOPinTypeLCD_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeLCD_IgnoreBool = (char)0;
}

void GPIOPinTypeLCD_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeLCD_CALL_INSTANCE));
  CMOCK_GPIOPinTypeLCD_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeLCD_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeLCD_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeLCD_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeLCD_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeLCD(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeLCD_AddCallback(CMOCK_GPIOPinTypeLCD_CALLBACK Callback)
{
  Mock.GPIOPinTypeLCD_IgnoreBool = (char)0;
  Mock.GPIOPinTypeLCD_CallbackBool = (char)1;
  Mock.GPIOPinTypeLCD_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeLCD_Stub(CMOCK_GPIOPinTypeLCD_CALLBACK Callback)
{
  Mock.GPIOPinTypeLCD_IgnoreBool = (char)0;
  Mock.GPIOPinTypeLCD_CallbackBool = (char)0;
  Mock.GPIOPinTypeLCD_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeOneWire(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeOneWire);
  cmock_call_instance = (CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeOneWire_CallInstance);
  Mock.GPIOPinTypeOneWire_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeOneWire_CallInstance);
  if (Mock.GPIOPinTypeOneWire_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeOneWire_CallbackBool &&
      Mock.GPIOPinTypeOneWire_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeOneWire_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeOneWire_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeOneWire,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeOneWire,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeOneWire_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeOneWire_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeOneWire_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeOneWire(CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeOneWire(CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeOneWire_CMockIgnore(void)
{
  Mock.GPIOPinTypeOneWire_IgnoreBool = (char)1;
}

void GPIOPinTypeOneWire_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeOneWire_IgnoreBool = (char)0;
}

void GPIOPinTypeOneWire_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE));
  CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeOneWire_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeOneWire_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeOneWire_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeOneWire_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeOneWire(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeOneWire_AddCallback(CMOCK_GPIOPinTypeOneWire_CALLBACK Callback)
{
  Mock.GPIOPinTypeOneWire_IgnoreBool = (char)0;
  Mock.GPIOPinTypeOneWire_CallbackBool = (char)1;
  Mock.GPIOPinTypeOneWire_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeOneWire_Stub(CMOCK_GPIOPinTypeOneWire_CALLBACK Callback)
{
  Mock.GPIOPinTypeOneWire_IgnoreBool = (char)0;
  Mock.GPIOPinTypeOneWire_CallbackBool = (char)0;
  Mock.GPIOPinTypeOneWire_CallbackFunctionPointer = Callback;
}

void GPIOPinTypePWM(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypePWM_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypePWM);
  cmock_call_instance = (CMOCK_GPIOPinTypePWM_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypePWM_CallInstance);
  Mock.GPIOPinTypePWM_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypePWM_CallInstance);
  if (Mock.GPIOPinTypePWM_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypePWM_CallbackBool &&
      Mock.GPIOPinTypePWM_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypePWM_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypePWM_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypePWM,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypePWM,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypePWM_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypePWM_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypePWM_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypePWM(CMOCK_GPIOPinTypePWM_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypePWM(CMOCK_GPIOPinTypePWM_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypePWM_CMockIgnore(void)
{
  Mock.GPIOPinTypePWM_IgnoreBool = (char)1;
}

void GPIOPinTypePWM_CMockStopIgnore(void)
{
  Mock.GPIOPinTypePWM_IgnoreBool = (char)0;
}

void GPIOPinTypePWM_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypePWM_CALL_INSTANCE));
  CMOCK_GPIOPinTypePWM_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypePWM_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypePWM_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypePWM_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypePWM_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypePWM(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypePWM_AddCallback(CMOCK_GPIOPinTypePWM_CALLBACK Callback)
{
  Mock.GPIOPinTypePWM_IgnoreBool = (char)0;
  Mock.GPIOPinTypePWM_CallbackBool = (char)1;
  Mock.GPIOPinTypePWM_CallbackFunctionPointer = Callback;
}

void GPIOPinTypePWM_Stub(CMOCK_GPIOPinTypePWM_CALLBACK Callback)
{
  Mock.GPIOPinTypePWM_IgnoreBool = (char)0;
  Mock.GPIOPinTypePWM_CallbackBool = (char)0;
  Mock.GPIOPinTypePWM_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeQEI(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeQEI_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeQEI);
  cmock_call_instance = (CMOCK_GPIOPinTypeQEI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeQEI_CallInstance);
  Mock.GPIOPinTypeQEI_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeQEI_CallInstance);
  if (Mock.GPIOPinTypeQEI_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeQEI_CallbackBool &&
      Mock.GPIOPinTypeQEI_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeQEI_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeQEI_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeQEI,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeQEI,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeQEI_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeQEI_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeQEI_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeQEI(CMOCK_GPIOPinTypeQEI_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeQEI(CMOCK_GPIOPinTypeQEI_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeQEI_CMockIgnore(void)
{
  Mock.GPIOPinTypeQEI_IgnoreBool = (char)1;
}

void GPIOPinTypeQEI_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeQEI_IgnoreBool = (char)0;
}

void GPIOPinTypeQEI_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeQEI_CALL_INSTANCE));
  CMOCK_GPIOPinTypeQEI_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeQEI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeQEI_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeQEI_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeQEI_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeQEI(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeQEI_AddCallback(CMOCK_GPIOPinTypeQEI_CALLBACK Callback)
{
  Mock.GPIOPinTypeQEI_IgnoreBool = (char)0;
  Mock.GPIOPinTypeQEI_CallbackBool = (char)1;
  Mock.GPIOPinTypeQEI_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeQEI_Stub(CMOCK_GPIOPinTypeQEI_CALLBACK Callback)
{
  Mock.GPIOPinTypeQEI_IgnoreBool = (char)0;
  Mock.GPIOPinTypeQEI_CallbackBool = (char)0;
  Mock.GPIOPinTypeQEI_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeSSI(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeSSI_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeSSI);
  cmock_call_instance = (CMOCK_GPIOPinTypeSSI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeSSI_CallInstance);
  Mock.GPIOPinTypeSSI_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeSSI_CallInstance);
  if (Mock.GPIOPinTypeSSI_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeSSI_CallbackBool &&
      Mock.GPIOPinTypeSSI_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeSSI_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeSSI_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeSSI,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeSSI,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeSSI_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeSSI_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeSSI_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeSSI(CMOCK_GPIOPinTypeSSI_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeSSI(CMOCK_GPIOPinTypeSSI_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeSSI_CMockIgnore(void)
{
  Mock.GPIOPinTypeSSI_IgnoreBool = (char)1;
}

void GPIOPinTypeSSI_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeSSI_IgnoreBool = (char)0;
}

void GPIOPinTypeSSI_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeSSI_CALL_INSTANCE));
  CMOCK_GPIOPinTypeSSI_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeSSI_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeSSI_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeSSI_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeSSI_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeSSI(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeSSI_AddCallback(CMOCK_GPIOPinTypeSSI_CALLBACK Callback)
{
  Mock.GPIOPinTypeSSI_IgnoreBool = (char)0;
  Mock.GPIOPinTypeSSI_CallbackBool = (char)1;
  Mock.GPIOPinTypeSSI_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeSSI_Stub(CMOCK_GPIOPinTypeSSI_CALLBACK Callback)
{
  Mock.GPIOPinTypeSSI_IgnoreBool = (char)0;
  Mock.GPIOPinTypeSSI_CallbackBool = (char)0;
  Mock.GPIOPinTypeSSI_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeTimer(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeTimer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeTimer);
  cmock_call_instance = (CMOCK_GPIOPinTypeTimer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeTimer_CallInstance);
  Mock.GPIOPinTypeTimer_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeTimer_CallInstance);
  if (Mock.GPIOPinTypeTimer_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeTimer_CallbackBool &&
      Mock.GPIOPinTypeTimer_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeTimer_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeTimer_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeTimer,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeTimer,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeTimer_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeTimer_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeTimer_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeTimer(CMOCK_GPIOPinTypeTimer_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeTimer(CMOCK_GPIOPinTypeTimer_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeTimer_CMockIgnore(void)
{
  Mock.GPIOPinTypeTimer_IgnoreBool = (char)1;
}

void GPIOPinTypeTimer_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeTimer_IgnoreBool = (char)0;
}

void GPIOPinTypeTimer_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeTimer_CALL_INSTANCE));
  CMOCK_GPIOPinTypeTimer_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeTimer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeTimer_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeTimer_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeTimer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeTimer(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeTimer_AddCallback(CMOCK_GPIOPinTypeTimer_CALLBACK Callback)
{
  Mock.GPIOPinTypeTimer_IgnoreBool = (char)0;
  Mock.GPIOPinTypeTimer_CallbackBool = (char)1;
  Mock.GPIOPinTypeTimer_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeTimer_Stub(CMOCK_GPIOPinTypeTimer_CALLBACK Callback)
{
  Mock.GPIOPinTypeTimer_IgnoreBool = (char)0;
  Mock.GPIOPinTypeTimer_CallbackBool = (char)0;
  Mock.GPIOPinTypeTimer_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeTrace(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeTrace_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeTrace);
  cmock_call_instance = (CMOCK_GPIOPinTypeTrace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeTrace_CallInstance);
  Mock.GPIOPinTypeTrace_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeTrace_CallInstance);
  if (Mock.GPIOPinTypeTrace_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeTrace_CallbackBool &&
      Mock.GPIOPinTypeTrace_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeTrace_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeTrace_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeTrace,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeTrace,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeTrace_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeTrace_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeTrace_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeTrace(CMOCK_GPIOPinTypeTrace_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeTrace(CMOCK_GPIOPinTypeTrace_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeTrace_CMockIgnore(void)
{
  Mock.GPIOPinTypeTrace_IgnoreBool = (char)1;
}

void GPIOPinTypeTrace_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeTrace_IgnoreBool = (char)0;
}

void GPIOPinTypeTrace_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeTrace_CALL_INSTANCE));
  CMOCK_GPIOPinTypeTrace_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeTrace_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeTrace_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeTrace_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeTrace_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeTrace(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeTrace_AddCallback(CMOCK_GPIOPinTypeTrace_CALLBACK Callback)
{
  Mock.GPIOPinTypeTrace_IgnoreBool = (char)0;
  Mock.GPIOPinTypeTrace_CallbackBool = (char)1;
  Mock.GPIOPinTypeTrace_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeTrace_Stub(CMOCK_GPIOPinTypeTrace_CALLBACK Callback)
{
  Mock.GPIOPinTypeTrace_IgnoreBool = (char)0;
  Mock.GPIOPinTypeTrace_CallbackBool = (char)0;
  Mock.GPIOPinTypeTrace_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeUART(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeUART_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeUART);
  cmock_call_instance = (CMOCK_GPIOPinTypeUART_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeUART_CallInstance);
  Mock.GPIOPinTypeUART_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeUART_CallInstance);
  if (Mock.GPIOPinTypeUART_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeUART_CallbackBool &&
      Mock.GPIOPinTypeUART_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeUART_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeUART_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeUART,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeUART,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeUART_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeUART_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeUART_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeUART(CMOCK_GPIOPinTypeUART_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeUART(CMOCK_GPIOPinTypeUART_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeUART_CMockIgnore(void)
{
  Mock.GPIOPinTypeUART_IgnoreBool = (char)1;
}

void GPIOPinTypeUART_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeUART_IgnoreBool = (char)0;
}

void GPIOPinTypeUART_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeUART_CALL_INSTANCE));
  CMOCK_GPIOPinTypeUART_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeUART_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeUART_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeUART_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeUART_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeUART(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeUART_AddCallback(CMOCK_GPIOPinTypeUART_CALLBACK Callback)
{
  Mock.GPIOPinTypeUART_IgnoreBool = (char)0;
  Mock.GPIOPinTypeUART_CallbackBool = (char)1;
  Mock.GPIOPinTypeUART_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeUART_Stub(CMOCK_GPIOPinTypeUART_CALLBACK Callback)
{
  Mock.GPIOPinTypeUART_IgnoreBool = (char)0;
  Mock.GPIOPinTypeUART_CallbackBool = (char)0;
  Mock.GPIOPinTypeUART_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeUSBAnalog(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeUSBAnalog);
  cmock_call_instance = (CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeUSBAnalog_CallInstance);
  Mock.GPIOPinTypeUSBAnalog_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeUSBAnalog_CallInstance);
  if (Mock.GPIOPinTypeUSBAnalog_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeUSBAnalog_CallbackBool &&
      Mock.GPIOPinTypeUSBAnalog_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeUSBAnalog_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeUSBAnalog_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeUSBAnalog,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeUSBAnalog,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeUSBAnalog_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeUSBAnalog_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeUSBAnalog_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeUSBAnalog(CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeUSBAnalog(CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeUSBAnalog_CMockIgnore(void)
{
  Mock.GPIOPinTypeUSBAnalog_IgnoreBool = (char)1;
}

void GPIOPinTypeUSBAnalog_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeUSBAnalog_IgnoreBool = (char)0;
}

void GPIOPinTypeUSBAnalog_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE));
  CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeUSBAnalog_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeUSBAnalog_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeUSBAnalog_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeUSBAnalog_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeUSBAnalog(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeUSBAnalog_AddCallback(CMOCK_GPIOPinTypeUSBAnalog_CALLBACK Callback)
{
  Mock.GPIOPinTypeUSBAnalog_IgnoreBool = (char)0;
  Mock.GPIOPinTypeUSBAnalog_CallbackBool = (char)1;
  Mock.GPIOPinTypeUSBAnalog_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeUSBAnalog_Stub(CMOCK_GPIOPinTypeUSBAnalog_CALLBACK Callback)
{
  Mock.GPIOPinTypeUSBAnalog_IgnoreBool = (char)0;
  Mock.GPIOPinTypeUSBAnalog_CallbackBool = (char)0;
  Mock.GPIOPinTypeUSBAnalog_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeUSBDigital(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeUSBDigital);
  cmock_call_instance = (CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeUSBDigital_CallInstance);
  Mock.GPIOPinTypeUSBDigital_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeUSBDigital_CallInstance);
  if (Mock.GPIOPinTypeUSBDigital_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeUSBDigital_CallbackBool &&
      Mock.GPIOPinTypeUSBDigital_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeUSBDigital_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeUSBDigital_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeUSBDigital,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeUSBDigital,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeUSBDigital_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeUSBDigital_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeUSBDigital_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeUSBDigital(CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeUSBDigital(CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeUSBDigital_CMockIgnore(void)
{
  Mock.GPIOPinTypeUSBDigital_IgnoreBool = (char)1;
}

void GPIOPinTypeUSBDigital_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeUSBDigital_IgnoreBool = (char)0;
}

void GPIOPinTypeUSBDigital_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE));
  CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeUSBDigital_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeUSBDigital_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeUSBDigital_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeUSBDigital_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeUSBDigital(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeUSBDigital_AddCallback(CMOCK_GPIOPinTypeUSBDigital_CALLBACK Callback)
{
  Mock.GPIOPinTypeUSBDigital_IgnoreBool = (char)0;
  Mock.GPIOPinTypeUSBDigital_CallbackBool = (char)1;
  Mock.GPIOPinTypeUSBDigital_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeUSBDigital_Stub(CMOCK_GPIOPinTypeUSBDigital_CALLBACK Callback)
{
  Mock.GPIOPinTypeUSBDigital_IgnoreBool = (char)0;
  Mock.GPIOPinTypeUSBDigital_CallbackBool = (char)0;
  Mock.GPIOPinTypeUSBDigital_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeWakeHigh(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeWakeHigh);
  cmock_call_instance = (CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeWakeHigh_CallInstance);
  Mock.GPIOPinTypeWakeHigh_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeWakeHigh_CallInstance);
  if (Mock.GPIOPinTypeWakeHigh_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeWakeHigh_CallbackBool &&
      Mock.GPIOPinTypeWakeHigh_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeWakeHigh_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeWakeHigh_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeWakeHigh,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeWakeHigh,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeWakeHigh_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeWakeHigh_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeWakeHigh_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeWakeHigh(CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeWakeHigh(CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeWakeHigh_CMockIgnore(void)
{
  Mock.GPIOPinTypeWakeHigh_IgnoreBool = (char)1;
}

void GPIOPinTypeWakeHigh_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeWakeHigh_IgnoreBool = (char)0;
}

void GPIOPinTypeWakeHigh_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE));
  CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeWakeHigh_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeWakeHigh_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeWakeHigh_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeWakeHigh_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeWakeHigh(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeWakeHigh_AddCallback(CMOCK_GPIOPinTypeWakeHigh_CALLBACK Callback)
{
  Mock.GPIOPinTypeWakeHigh_IgnoreBool = (char)0;
  Mock.GPIOPinTypeWakeHigh_CallbackBool = (char)1;
  Mock.GPIOPinTypeWakeHigh_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeWakeHigh_Stub(CMOCK_GPIOPinTypeWakeHigh_CALLBACK Callback)
{
  Mock.GPIOPinTypeWakeHigh_IgnoreBool = (char)0;
  Mock.GPIOPinTypeWakeHigh_CallbackBool = (char)0;
  Mock.GPIOPinTypeWakeHigh_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeWakeLow(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinTypeWakeLow);
  cmock_call_instance = (CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinTypeWakeLow_CallInstance);
  Mock.GPIOPinTypeWakeLow_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinTypeWakeLow_CallInstance);
  if (Mock.GPIOPinTypeWakeLow_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOPinTypeWakeLow_CallbackBool &&
      Mock.GPIOPinTypeWakeLow_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeWakeLow_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeWakeLow_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeWakeLow,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinTypeWakeLow,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinTypeWakeLow_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOPinTypeWakeLow_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOPinTypeWakeLow_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOPinTypeWakeLow(CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOPinTypeWakeLow(CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOPinTypeWakeLow_CMockIgnore(void)
{
  Mock.GPIOPinTypeWakeLow_IgnoreBool = (char)1;
}

void GPIOPinTypeWakeLow_CMockStopIgnore(void)
{
  Mock.GPIOPinTypeWakeLow_IgnoreBool = (char)0;
}

void GPIOPinTypeWakeLow_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE));
  CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinTypeWakeLow_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinTypeWakeLow_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinTypeWakeLow_CallInstance, cmock_guts_index);
  Mock.GPIOPinTypeWakeLow_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinTypeWakeLow(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOPinTypeWakeLow_AddCallback(CMOCK_GPIOPinTypeWakeLow_CALLBACK Callback)
{
  Mock.GPIOPinTypeWakeLow_IgnoreBool = (char)0;
  Mock.GPIOPinTypeWakeLow_CallbackBool = (char)1;
  Mock.GPIOPinTypeWakeLow_CallbackFunctionPointer = Callback;
}

void GPIOPinTypeWakeLow_Stub(CMOCK_GPIOPinTypeWakeLow_CALLBACK Callback)
{
  Mock.GPIOPinTypeWakeLow_IgnoreBool = (char)0;
  Mock.GPIOPinTypeWakeLow_CallbackBool = (char)0;
  Mock.GPIOPinTypeWakeLow_CallbackFunctionPointer = Callback;
}

uint32_t GPIOPinWakeStatus(uint32_t ui32Port)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOPinWakeStatus_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOPinWakeStatus);
  cmock_call_instance = (CMOCK_GPIOPinWakeStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOPinWakeStatus_CallInstance);
  Mock.GPIOPinWakeStatus_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinWakeStatus_CallInstance);
  if (Mock.GPIOPinWakeStatus_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.GPIOPinWakeStatus_FinalReturn;
    Mock.GPIOPinWakeStatus_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.GPIOPinWakeStatus_CallbackBool &&
      Mock.GPIOPinWakeStatus_CallbackFunctionPointer != NULL)
  {
    uint32_t cmock_cb_ret = Mock.GPIOPinWakeStatus_CallbackFunctionPointer(ui32Port, Mock.GPIOPinWakeStatus_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOPinWakeStatus,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOPinWakeStatus_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.GPIOPinWakeStatus_CallbackFunctionPointer(ui32Port, Mock.GPIOPinWakeStatus_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_GPIOPinWakeStatus(CMOCK_GPIOPinWakeStatus_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port);
void CMockExpectParameters_GPIOPinWakeStatus(CMOCK_GPIOPinWakeStatus_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
}

void GPIOPinWakeStatus_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinWakeStatus_CALL_INSTANCE));
  CMOCK_GPIOPinWakeStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinWakeStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinWakeStatus_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinWakeStatus_CallInstance, cmock_guts_index);
  Mock.GPIOPinWakeStatus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.GPIOPinWakeStatus_IgnoreBool = (char)1;
}

void GPIOPinWakeStatus_CMockStopIgnore(void)
{
  if(Mock.GPIOPinWakeStatus_IgnoreBool)
    Mock.GPIOPinWakeStatus_CallInstance = CMock_Guts_MemNext(Mock.GPIOPinWakeStatus_CallInstance);
  Mock.GPIOPinWakeStatus_IgnoreBool = (char)0;
}

void GPIOPinWakeStatus_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOPinWakeStatus_CALL_INSTANCE));
  CMOCK_GPIOPinWakeStatus_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOPinWakeStatus_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOPinWakeStatus_CallInstance = CMock_Guts_MemChain(Mock.GPIOPinWakeStatus_CallInstance, cmock_guts_index);
  Mock.GPIOPinWakeStatus_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOPinWakeStatus(cmock_call_instance, ui32Port);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void GPIOPinWakeStatus_AddCallback(CMOCK_GPIOPinWakeStatus_CALLBACK Callback)
{
  Mock.GPIOPinWakeStatus_IgnoreBool = (char)0;
  Mock.GPIOPinWakeStatus_CallbackBool = (char)1;
  Mock.GPIOPinWakeStatus_CallbackFunctionPointer = Callback;
}

void GPIOPinWakeStatus_Stub(CMOCK_GPIOPinWakeStatus_CALLBACK Callback)
{
  Mock.GPIOPinWakeStatus_IgnoreBool = (char)0;
  Mock.GPIOPinWakeStatus_CallbackBool = (char)0;
  Mock.GPIOPinWakeStatus_CallbackFunctionPointer = Callback;
}

void GPIODMATriggerEnable(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIODMATriggerEnable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIODMATriggerEnable);
  cmock_call_instance = (CMOCK_GPIODMATriggerEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIODMATriggerEnable_CallInstance);
  Mock.GPIODMATriggerEnable_CallInstance = CMock_Guts_MemNext(Mock.GPIODMATriggerEnable_CallInstance);
  if (Mock.GPIODMATriggerEnable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIODMATriggerEnable_CallbackBool &&
      Mock.GPIODMATriggerEnable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIODMATriggerEnable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIODMATriggerEnable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIODMATriggerEnable,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIODMATriggerEnable,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIODMATriggerEnable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIODMATriggerEnable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIODMATriggerEnable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIODMATriggerEnable(CMOCK_GPIODMATriggerEnable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIODMATriggerEnable(CMOCK_GPIODMATriggerEnable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIODMATriggerEnable_CMockIgnore(void)
{
  Mock.GPIODMATriggerEnable_IgnoreBool = (char)1;
}

void GPIODMATriggerEnable_CMockStopIgnore(void)
{
  Mock.GPIODMATriggerEnable_IgnoreBool = (char)0;
}

void GPIODMATriggerEnable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIODMATriggerEnable_CALL_INSTANCE));
  CMOCK_GPIODMATriggerEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIODMATriggerEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIODMATriggerEnable_CallInstance = CMock_Guts_MemChain(Mock.GPIODMATriggerEnable_CallInstance, cmock_guts_index);
  Mock.GPIODMATriggerEnable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIODMATriggerEnable(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIODMATriggerEnable_AddCallback(CMOCK_GPIODMATriggerEnable_CALLBACK Callback)
{
  Mock.GPIODMATriggerEnable_IgnoreBool = (char)0;
  Mock.GPIODMATriggerEnable_CallbackBool = (char)1;
  Mock.GPIODMATriggerEnable_CallbackFunctionPointer = Callback;
}

void GPIODMATriggerEnable_Stub(CMOCK_GPIODMATriggerEnable_CALLBACK Callback)
{
  Mock.GPIODMATriggerEnable_IgnoreBool = (char)0;
  Mock.GPIODMATriggerEnable_CallbackBool = (char)0;
  Mock.GPIODMATriggerEnable_CallbackFunctionPointer = Callback;
}

void GPIODMATriggerDisable(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIODMATriggerDisable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIODMATriggerDisable);
  cmock_call_instance = (CMOCK_GPIODMATriggerDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIODMATriggerDisable_CallInstance);
  Mock.GPIODMATriggerDisable_CallInstance = CMock_Guts_MemNext(Mock.GPIODMATriggerDisable_CallInstance);
  if (Mock.GPIODMATriggerDisable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIODMATriggerDisable_CallbackBool &&
      Mock.GPIODMATriggerDisable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIODMATriggerDisable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIODMATriggerDisable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIODMATriggerDisable,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIODMATriggerDisable,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIODMATriggerDisable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIODMATriggerDisable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIODMATriggerDisable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIODMATriggerDisable(CMOCK_GPIODMATriggerDisable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIODMATriggerDisable(CMOCK_GPIODMATriggerDisable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIODMATriggerDisable_CMockIgnore(void)
{
  Mock.GPIODMATriggerDisable_IgnoreBool = (char)1;
}

void GPIODMATriggerDisable_CMockStopIgnore(void)
{
  Mock.GPIODMATriggerDisable_IgnoreBool = (char)0;
}

void GPIODMATriggerDisable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIODMATriggerDisable_CALL_INSTANCE));
  CMOCK_GPIODMATriggerDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIODMATriggerDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIODMATriggerDisable_CallInstance = CMock_Guts_MemChain(Mock.GPIODMATriggerDisable_CallInstance, cmock_guts_index);
  Mock.GPIODMATriggerDisable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIODMATriggerDisable(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIODMATriggerDisable_AddCallback(CMOCK_GPIODMATriggerDisable_CALLBACK Callback)
{
  Mock.GPIODMATriggerDisable_IgnoreBool = (char)0;
  Mock.GPIODMATriggerDisable_CallbackBool = (char)1;
  Mock.GPIODMATriggerDisable_CallbackFunctionPointer = Callback;
}

void GPIODMATriggerDisable_Stub(CMOCK_GPIODMATriggerDisable_CALLBACK Callback)
{
  Mock.GPIODMATriggerDisable_IgnoreBool = (char)0;
  Mock.GPIODMATriggerDisable_CallbackBool = (char)0;
  Mock.GPIODMATriggerDisable_CallbackFunctionPointer = Callback;
}

void GPIOADCTriggerEnable(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOADCTriggerEnable);
  cmock_call_instance = (CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOADCTriggerEnable_CallInstance);
  Mock.GPIOADCTriggerEnable_CallInstance = CMock_Guts_MemNext(Mock.GPIOADCTriggerEnable_CallInstance);
  if (Mock.GPIOADCTriggerEnable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOADCTriggerEnable_CallbackBool &&
      Mock.GPIOADCTriggerEnable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOADCTriggerEnable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOADCTriggerEnable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOADCTriggerEnable,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOADCTriggerEnable,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOADCTriggerEnable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOADCTriggerEnable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOADCTriggerEnable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOADCTriggerEnable(CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOADCTriggerEnable(CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOADCTriggerEnable_CMockIgnore(void)
{
  Mock.GPIOADCTriggerEnable_IgnoreBool = (char)1;
}

void GPIOADCTriggerEnable_CMockStopIgnore(void)
{
  Mock.GPIOADCTriggerEnable_IgnoreBool = (char)0;
}

void GPIOADCTriggerEnable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE));
  CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOADCTriggerEnable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOADCTriggerEnable_CallInstance = CMock_Guts_MemChain(Mock.GPIOADCTriggerEnable_CallInstance, cmock_guts_index);
  Mock.GPIOADCTriggerEnable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOADCTriggerEnable(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOADCTriggerEnable_AddCallback(CMOCK_GPIOADCTriggerEnable_CALLBACK Callback)
{
  Mock.GPIOADCTriggerEnable_IgnoreBool = (char)0;
  Mock.GPIOADCTriggerEnable_CallbackBool = (char)1;
  Mock.GPIOADCTriggerEnable_CallbackFunctionPointer = Callback;
}

void GPIOADCTriggerEnable_Stub(CMOCK_GPIOADCTriggerEnable_CALLBACK Callback)
{
  Mock.GPIOADCTriggerEnable_IgnoreBool = (char)0;
  Mock.GPIOADCTriggerEnable_CallbackBool = (char)0;
  Mock.GPIOADCTriggerEnable_CallbackFunctionPointer = Callback;
}

void GPIOADCTriggerDisable(uint32_t ui32Port, uint8_t ui8Pins)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_GPIOADCTriggerDisable);
  cmock_call_instance = (CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.GPIOADCTriggerDisable_CallInstance);
  Mock.GPIOADCTriggerDisable_CallInstance = CMock_Guts_MemNext(Mock.GPIOADCTriggerDisable_CallInstance);
  if (Mock.GPIOADCTriggerDisable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.GPIOADCTriggerDisable_CallbackBool &&
      Mock.GPIOADCTriggerDisable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOADCTriggerDisable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOADCTriggerDisable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  {
    UNITY_SET_DETAILS(CMockString_GPIOADCTriggerDisable,CMockString_ui32Port);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ui32Port, ui32Port, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_GPIOADCTriggerDisable,CMockString_ui8Pins);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_ui8Pins, ui8Pins, cmock_line, CMockStringMismatch);
  }
  if (Mock.GPIOADCTriggerDisable_CallbackFunctionPointer != NULL)
  {
    Mock.GPIOADCTriggerDisable_CallbackFunctionPointer(ui32Port, ui8Pins, Mock.GPIOADCTriggerDisable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_GPIOADCTriggerDisable(CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins);
void CMockExpectParameters_GPIOADCTriggerDisable(CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE* cmock_call_instance, uint32_t ui32Port, uint8_t ui8Pins)
{
  cmock_call_instance->Expected_ui32Port = ui32Port;
  cmock_call_instance->Expected_ui8Pins = ui8Pins;
}

void GPIOADCTriggerDisable_CMockIgnore(void)
{
  Mock.GPIOADCTriggerDisable_IgnoreBool = (char)1;
}

void GPIOADCTriggerDisable_CMockStopIgnore(void)
{
  Mock.GPIOADCTriggerDisable_IgnoreBool = (char)0;
}

void GPIOADCTriggerDisable_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t ui32Port, uint8_t ui8Pins)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE));
  CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE* cmock_call_instance = (CMOCK_GPIOADCTriggerDisable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.GPIOADCTriggerDisable_CallInstance = CMock_Guts_MemChain(Mock.GPIOADCTriggerDisable_CallInstance, cmock_guts_index);
  Mock.GPIOADCTriggerDisable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_GPIOADCTriggerDisable(cmock_call_instance, ui32Port, ui8Pins);
}

void GPIOADCTriggerDisable_AddCallback(CMOCK_GPIOADCTriggerDisable_CALLBACK Callback)
{
  Mock.GPIOADCTriggerDisable_IgnoreBool = (char)0;
  Mock.GPIOADCTriggerDisable_CallbackBool = (char)1;
  Mock.GPIOADCTriggerDisable_CallbackFunctionPointer = Callback;
}

void GPIOADCTriggerDisable_Stub(CMOCK_GPIOADCTriggerDisable_CALLBACK Callback)
{
  Mock.GPIOADCTriggerDisable_IgnoreBool = (char)0;
  Mock.GPIOADCTriggerDisable_CallbackBool = (char)0;
  Mock.GPIOADCTriggerDisable_CallbackFunctionPointer = Callback;
}

